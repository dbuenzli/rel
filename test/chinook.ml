(* Generated by ask-sqlite3 %VERSION% *)

module Tracks : sig
  type t
  val row : int -> string -> int option -> int -> int option ->
            string option -> int -> int option -> float -> t
  
  val trackId : t -> int
  val name : t -> string
  val albumId : t -> int option
  val mediaTypeId : t -> int
  val genreId : t -> int option
  val composer : t -> string option
  val milliseconds : t -> int
  val bytes : t -> int option
  val unitPrice : t -> float
  
  module C : sig
    val trackId : (t, int) Ask.Col.t
    val name : (t, string) Ask.Col.t
    val albumId : (t, int option) Ask.Col.t
    val mediaTypeId : (t, int) Ask.Col.t
    val genreId : (t, int option) Ask.Col.t
    val composer : (t, string option) Ask.Col.t
    val milliseconds : (t, int) Ask.Col.t
    val bytes : (t, int option) Ask.Col.t
    val unitPrice : (t, float) Ask.Col.t
  end
  
  val table : t Ask.Table.t
end = struct
  type t =
    { trackId : int;
      name : string;
      albumId : int option;
      mediaTypeId : int;
      genreId : int option;
      composer : string option;
      milliseconds : int;
      bytes : int option;
      unitPrice : float; }
    
  let row trackId name albumId mediaTypeId genreId composer milliseconds
          bytes unitPrice =
  { trackId; name; albumId; mediaTypeId; genreId; composer; milliseconds;
    bytes; unitPrice }
  
  let trackId t = t.trackId
  let name t = t.name
  let albumId t = t.albumId
  let mediaTypeId t = t.mediaTypeId
  let genreId t = t.genreId
  let composer t = t.composer
  let milliseconds t = t.milliseconds
  let bytes t = t.bytes
  let unitPrice t = t.unitPrice
  
  open Ask
  module C = struct
    let trackId = Col.v "TrackId" Type.Int trackId
    let name = Col.v "Name" Type.Text name
    let albumId = Col.v "AlbumId" Type.(Option Int) albumId
    let mediaTypeId = Col.v "MediaTypeId" Type.Int mediaTypeId
    let genreId = Col.v "GenreId" Type.(Option Int) genreId
    let composer = Col.v "Composer" Type.(Option Text) composer
    let milliseconds = Col.v "Milliseconds" Type.Int milliseconds
    let bytes = Col.v "Bytes" Type.(Option Int) bytes
    let unitPrice = Col.v "UnitPrice" Type.Float unitPrice
  end
  
  let table =
    Table.v "tracks"
      Row.Cols.(unit row * C.trackId * C.name * C.albumId * C.mediaTypeId *
                C.genreId * C.composer * C.milliseconds * C.bytes *
                C.unitPrice)
end

module Sqlite_stat1 : sig
  type t
  val row : string option -> string option -> string option -> t
  
  val tbl : t -> string option
  val idx : t -> string option
  val stat : t -> string option
  
  module C : sig
    val tbl : (t, string option) Ask.Col.t
    val idx : (t, string option) Ask.Col.t
    val stat : (t, string option) Ask.Col.t
  end
  
  val table : t Ask.Table.t
end = struct
  type t =
    { tbl : string option;
      idx : string option;
      stat : string option; }
    
  let row tbl idx stat = { tbl; idx; stat }
  
  let tbl t = t.tbl
  let idx t = t.idx
  let stat t = t.stat
  
  open Ask
  module C = struct
    let tbl = Col.v "tbl" Type.(Option Blob) tbl
    let idx = Col.v "idx" Type.(Option Blob) idx
    let stat = Col.v "stat" Type.(Option Blob) stat
  end
  
  let table =
    Table.v "sqlite_stat1" Row.Cols.(unit row * C.tbl * C.idx * C.stat)
end

module Sqlite_sequence : sig
  type t
  val row : string option -> string option -> t
  
  val name : t -> string option
  val seq : t -> string option
  
  module C : sig
    val name : (t, string option) Ask.Col.t
    val seq : (t, string option) Ask.Col.t
  end
  
  val table : t Ask.Table.t
end = struct
  type t =
    { name : string option;
      seq : string option; }
    
  let row name seq = { name; seq }
  
  let name t = t.name
  let seq t = t.seq
  
  open Ask
  module C = struct
    let name = Col.v "name" Type.(Option Blob) name
    let seq = Col.v "seq" Type.(Option Blob) seq
  end
  
  let table =
    Table.v "sqlite_sequence" Row.Cols.(unit row * C.name * C.seq)
end

module Playlists : sig
  type t
  val row : int -> string option -> t
  
  val playlistId : t -> int
  val name : t -> string option
  
  module C : sig
    val playlistId : (t, int) Ask.Col.t
    val name : (t, string option) Ask.Col.t
  end
  
  val table : t Ask.Table.t
end = struct
  type t =
    { playlistId : int;
      name : string option; }
    
  let row playlistId name = { playlistId; name }
  
  let playlistId t = t.playlistId
  let name t = t.name
  
  open Ask
  module C = struct
    let playlistId = Col.v "PlaylistId" Type.Int playlistId
    let name = Col.v "Name" Type.(Option Text) name
  end
  
  let table =
    Table.v "playlists" Row.Cols.(unit row * C.playlistId * C.name)
end

module Playlist_track : sig
  type t
  val row : int -> int -> t
  
  val playlistId : t -> int
  val trackId : t -> int
  
  module C : sig
    val playlistId : (t, int) Ask.Col.t
    val trackId : (t, int) Ask.Col.t
  end
  
  val table : t Ask.Table.t
end = struct
  type t =
    { playlistId : int;
      trackId : int; }
    
  let row playlistId trackId = { playlistId; trackId }
  
  let playlistId t = t.playlistId
  let trackId t = t.trackId
  
  open Ask
  module C = struct
    let playlistId = Col.v "PlaylistId" Type.Int playlistId
    let trackId = Col.v "TrackId" Type.Int trackId
  end
  
  let table =
    Table.v "playlist_track" Row.Cols.(unit row * C.playlistId * C.trackId)
end

module Media_types : sig
  type t
  val row : int -> string option -> t
  
  val mediaTypeId : t -> int
  val name : t -> string option
  
  module C : sig
    val mediaTypeId : (t, int) Ask.Col.t
    val name : (t, string option) Ask.Col.t
  end
  
  val table : t Ask.Table.t
end = struct
  type t =
    { mediaTypeId : int;
      name : string option; }
    
  let row mediaTypeId name = { mediaTypeId; name }
  
  let mediaTypeId t = t.mediaTypeId
  let name t = t.name
  
  open Ask
  module C = struct
    let mediaTypeId = Col.v "MediaTypeId" Type.Int mediaTypeId
    let name = Col.v "Name" Type.(Option Text) name
  end
  
  let table =
    Table.v "media_types" Row.Cols.(unit row * C.mediaTypeId * C.name)
end

module Invoices : sig
  type t
  val row : int -> int -> string -> string option -> string option ->
            string option -> string option -> string option -> float -> t
  
  val invoiceId : t -> int
  val customerId : t -> int
  val invoiceDate : t -> string
  val billingAddress : t -> string option
  val billingCity : t -> string option
  val billingState : t -> string option
  val billingCountry : t -> string option
  val billingPostalCode : t -> string option
  val total : t -> float
  
  module C : sig
    val invoiceId : (t, int) Ask.Col.t
    val customerId : (t, int) Ask.Col.t
    val invoiceDate : (t, string) Ask.Col.t
    val billingAddress : (t, string option) Ask.Col.t
    val billingCity : (t, string option) Ask.Col.t
    val billingState : (t, string option) Ask.Col.t
    val billingCountry : (t, string option) Ask.Col.t
    val billingPostalCode : (t, string option) Ask.Col.t
    val total : (t, float) Ask.Col.t
  end
  
  val table : t Ask.Table.t
end = struct
  type t =
    { invoiceId : int;
      customerId : int;
      invoiceDate : string;
      billingAddress : string option;
      billingCity : string option;
      billingState : string option;
      billingCountry : string option;
      billingPostalCode : string option;
      total : float; }
    
  let row invoiceId customerId invoiceDate billingAddress billingCity
          billingState billingCountry billingPostalCode total =
  { invoiceId; customerId; invoiceDate; billingAddress; billingCity;
    billingState; billingCountry; billingPostalCode; total }
  
  let invoiceId t = t.invoiceId
  let customerId t = t.customerId
  let invoiceDate t = t.invoiceDate
  let billingAddress t = t.billingAddress
  let billingCity t = t.billingCity
  let billingState t = t.billingState
  let billingCountry t = t.billingCountry
  let billingPostalCode t = t.billingPostalCode
  let total t = t.total
  
  open Ask
  module C = struct
    let invoiceId = Col.v "InvoiceId" Type.Int invoiceId
    let customerId = Col.v "CustomerId" Type.Int customerId
    let invoiceDate = Col.v "InvoiceDate" Type.Text invoiceDate
    let billingAddress = Col.v "BillingAddress" Type.(Option Text) billingAddress
    let billingCity = Col.v "BillingCity" Type.(Option Text) billingCity
    let billingState = Col.v "BillingState" Type.(Option Text) billingState
    let billingCountry = Col.v "BillingCountry" Type.(Option Text) billingCountry
    let billingPostalCode = Col.v "BillingPostalCode" Type.(Option Text) billingPostalCode
    let total = Col.v "Total" Type.Float total
  end
  
  let table =
    Table.v "invoices"
      Row.Cols.(unit row * C.invoiceId * C.customerId * C.invoiceDate *
                C.billingAddress * C.billingCity * C.billingState *
                C.billingCountry * C.billingPostalCode * C.total)
end

module Invoice_items : sig
  type t
  val row : int -> int -> int -> float -> int -> t
  
  val invoiceLineId : t -> int
  val invoiceId : t -> int
  val trackId : t -> int
  val unitPrice : t -> float
  val quantity : t -> int
  
  module C : sig
    val invoiceLineId : (t, int) Ask.Col.t
    val invoiceId : (t, int) Ask.Col.t
    val trackId : (t, int) Ask.Col.t
    val unitPrice : (t, float) Ask.Col.t
    val quantity : (t, int) Ask.Col.t
  end
  
  val table : t Ask.Table.t
end = struct
  type t =
    { invoiceLineId : int;
      invoiceId : int;
      trackId : int;
      unitPrice : float;
      quantity : int; }
    
  let row invoiceLineId invoiceId trackId unitPrice quantity =
  { invoiceLineId; invoiceId; trackId; unitPrice; quantity }
  
  let invoiceLineId t = t.invoiceLineId
  let invoiceId t = t.invoiceId
  let trackId t = t.trackId
  let unitPrice t = t.unitPrice
  let quantity t = t.quantity
  
  open Ask
  module C = struct
    let invoiceLineId = Col.v "InvoiceLineId" Type.Int invoiceLineId
    let invoiceId = Col.v "InvoiceId" Type.Int invoiceId
    let trackId = Col.v "TrackId" Type.Int trackId
    let unitPrice = Col.v "UnitPrice" Type.Float unitPrice
    let quantity = Col.v "Quantity" Type.Int quantity
  end
  
  let table =
    Table.v "invoice_items"
      Row.Cols.(unit row * C.invoiceLineId * C.invoiceId * C.trackId *
                C.unitPrice * C.quantity)
end

module Genres : sig
  type t
  val row : int -> string option -> t
  
  val genreId : t -> int
  val name : t -> string option
  
  module C : sig
    val genreId : (t, int) Ask.Col.t
    val name : (t, string option) Ask.Col.t
  end
  
  val table : t Ask.Table.t
end = struct
  type t =
    { genreId : int;
      name : string option; }
    
  let row genreId name = { genreId; name }
  
  let genreId t = t.genreId
  let name t = t.name
  
  open Ask
  module C = struct
    let genreId = Col.v "GenreId" Type.Int genreId
    let name = Col.v "Name" Type.(Option Text) name
  end
  
  let table =
    Table.v "genres" Row.Cols.(unit row * C.genreId * C.name)
end

module Employees : sig
  type t
  val row : int -> string -> string -> string option -> int option ->
            string option -> string option -> string option ->
            string option -> string option -> string option ->
            string option -> string option -> string option ->
            string option -> t
  
  val employeeId : t -> int
  val lastName : t -> string
  val firstName : t -> string
  val title : t -> string option
  val reportsTo : t -> int option
  val birthDate : t -> string option
  val hireDate : t -> string option
  val address : t -> string option
  val city : t -> string option
  val state : t -> string option
  val country : t -> string option
  val postalCode : t -> string option
  val phone : t -> string option
  val fax : t -> string option
  val email : t -> string option
  
  module C : sig
    val employeeId : (t, int) Ask.Col.t
    val lastName : (t, string) Ask.Col.t
    val firstName : (t, string) Ask.Col.t
    val title : (t, string option) Ask.Col.t
    val reportsTo : (t, int option) Ask.Col.t
    val birthDate : (t, string option) Ask.Col.t
    val hireDate : (t, string option) Ask.Col.t
    val address : (t, string option) Ask.Col.t
    val city : (t, string option) Ask.Col.t
    val state : (t, string option) Ask.Col.t
    val country : (t, string option) Ask.Col.t
    val postalCode : (t, string option) Ask.Col.t
    val phone : (t, string option) Ask.Col.t
    val fax : (t, string option) Ask.Col.t
    val email : (t, string option) Ask.Col.t
  end
  
  val table : t Ask.Table.t
end = struct
  type t =
    { employeeId : int;
      lastName : string;
      firstName : string;
      title : string option;
      reportsTo : int option;
      birthDate : string option;
      hireDate : string option;
      address : string option;
      city : string option;
      state : string option;
      country : string option;
      postalCode : string option;
      phone : string option;
      fax : string option;
      email : string option; }
    
  let row employeeId lastName firstName title reportsTo birthDate hireDate
          address city state country postalCode phone fax email =
  { employeeId; lastName; firstName; title; reportsTo; birthDate; hireDate;
    address; city; state; country; postalCode; phone; fax; email }
  
  let employeeId t = t.employeeId
  let lastName t = t.lastName
  let firstName t = t.firstName
  let title t = t.title
  let reportsTo t = t.reportsTo
  let birthDate t = t.birthDate
  let hireDate t = t.hireDate
  let address t = t.address
  let city t = t.city
  let state t = t.state
  let country t = t.country
  let postalCode t = t.postalCode
  let phone t = t.phone
  let fax t = t.fax
  let email t = t.email
  
  open Ask
  module C = struct
    let employeeId = Col.v "EmployeeId" Type.Int employeeId
    let lastName = Col.v "LastName" Type.Text lastName
    let firstName = Col.v "FirstName" Type.Text firstName
    let title = Col.v "Title" Type.(Option Text) title
    let reportsTo = Col.v "ReportsTo" Type.(Option Int) reportsTo
    let birthDate = Col.v "BirthDate" Type.(Option Text) birthDate
    let hireDate = Col.v "HireDate" Type.(Option Text) hireDate
    let address = Col.v "Address" Type.(Option Text) address
    let city = Col.v "City" Type.(Option Text) city
    let state = Col.v "State" Type.(Option Text) state
    let country = Col.v "Country" Type.(Option Text) country
    let postalCode = Col.v "PostalCode" Type.(Option Text) postalCode
    let phone = Col.v "Phone" Type.(Option Text) phone
    let fax = Col.v "Fax" Type.(Option Text) fax
    let email = Col.v "Email" Type.(Option Text) email
  end
  
  let table =
    Table.v "employees"
      Row.Cols.(unit row * C.employeeId * C.lastName * C.firstName *
                C.title * C.reportsTo * C.birthDate * C.hireDate *
                C.address * C.city * C.state * C.country * C.postalCode *
                C.phone * C.fax * C.email)
end

module Customers : sig
  type t
  val row : int -> string -> string -> string option -> string option ->
            string option -> string option -> string option ->
            string option -> string option -> string option -> string ->
            int option -> t
  
  val customerId : t -> int
  val firstName : t -> string
  val lastName : t -> string
  val company : t -> string option
  val address : t -> string option
  val city : t -> string option
  val state : t -> string option
  val country : t -> string option
  val postalCode : t -> string option
  val phone : t -> string option
  val fax : t -> string option
  val email : t -> string
  val supportRepId : t -> int option
  
  module C : sig
    val customerId : (t, int) Ask.Col.t
    val firstName : (t, string) Ask.Col.t
    val lastName : (t, string) Ask.Col.t
    val company : (t, string option) Ask.Col.t
    val address : (t, string option) Ask.Col.t
    val city : (t, string option) Ask.Col.t
    val state : (t, string option) Ask.Col.t
    val country : (t, string option) Ask.Col.t
    val postalCode : (t, string option) Ask.Col.t
    val phone : (t, string option) Ask.Col.t
    val fax : (t, string option) Ask.Col.t
    val email : (t, string) Ask.Col.t
    val supportRepId : (t, int option) Ask.Col.t
  end
  
  val table : t Ask.Table.t
end = struct
  type t =
    { customerId : int;
      firstName : string;
      lastName : string;
      company : string option;
      address : string option;
      city : string option;
      state : string option;
      country : string option;
      postalCode : string option;
      phone : string option;
      fax : string option;
      email : string;
      supportRepId : int option; }
    
  let row customerId firstName lastName company address city state country
          postalCode phone fax email supportRepId =
  { customerId; firstName; lastName; company; address; city; state; country;
    postalCode; phone; fax; email; supportRepId }
  
  let customerId t = t.customerId
  let firstName t = t.firstName
  let lastName t = t.lastName
  let company t = t.company
  let address t = t.address
  let city t = t.city
  let state t = t.state
  let country t = t.country
  let postalCode t = t.postalCode
  let phone t = t.phone
  let fax t = t.fax
  let email t = t.email
  let supportRepId t = t.supportRepId
  
  open Ask
  module C = struct
    let customerId = Col.v "CustomerId" Type.Int customerId
    let firstName = Col.v "FirstName" Type.Text firstName
    let lastName = Col.v "LastName" Type.Text lastName
    let company = Col.v "Company" Type.(Option Text) company
    let address = Col.v "Address" Type.(Option Text) address
    let city = Col.v "City" Type.(Option Text) city
    let state = Col.v "State" Type.(Option Text) state
    let country = Col.v "Country" Type.(Option Text) country
    let postalCode = Col.v "PostalCode" Type.(Option Text) postalCode
    let phone = Col.v "Phone" Type.(Option Text) phone
    let fax = Col.v "Fax" Type.(Option Text) fax
    let email = Col.v "Email" Type.Text email
    let supportRepId = Col.v "SupportRepId" Type.(Option Int) supportRepId
  end
  
  let table =
    Table.v "customers"
      Row.Cols.(unit row * C.customerId * C.firstName * C.lastName *
                C.company * C.address * C.city * C.state * C.country *
                C.postalCode * C.phone * C.fax * C.email * C.supportRepId)
end

module Artists : sig
  type t
  val row : int -> string option -> t
  
  val artistId : t -> int
  val name : t -> string option
  
  module C : sig
    val artistId : (t, int) Ask.Col.t
    val name : (t, string option) Ask.Col.t
  end
  
  val table : t Ask.Table.t
end = struct
  type t =
    { artistId : int;
      name : string option; }
    
  let row artistId name = { artistId; name }
  
  let artistId t = t.artistId
  let name t = t.name
  
  open Ask
  module C = struct
    let artistId = Col.v "ArtistId" Type.Int artistId
    let name = Col.v "Name" Type.(Option Text) name
  end
  
  let table =
    Table.v "artists" Row.Cols.(unit row * C.artistId * C.name)
end

module Albums : sig
  type t
  val row : int -> string -> int -> t
  
  val albumId : t -> int
  val title : t -> string
  val artistId : t -> int
  
  module C : sig
    val albumId : (t, int) Ask.Col.t
    val title : (t, string) Ask.Col.t
    val artistId : (t, int) Ask.Col.t
  end
  
  val table : t Ask.Table.t
end = struct
  type t =
    { albumId : int;
      title : string;
      artistId : int; }
    
  let row albumId title artistId = { albumId; title; artistId }
  
  let albumId t = t.albumId
  let title t = t.title
  let artistId t = t.artistId
  
  open Ask
  module C = struct
    let albumId = Col.v "AlbumId" Type.Int albumId
    let title = Col.v "Title" Type.Text title
    let artistId = Col.v "ArtistId" Type.Int artistId
  end
  
  let table =
    Table.v "albums" Row.Cols.(unit row * C.albumId * C.title * C.artistId)
end