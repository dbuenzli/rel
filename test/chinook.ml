(* Generated by rel %VERSION% *)

module Artist : sig
  type t
  
  val row : int -> string option -> t
  
  val artistId : t -> int
  val name : t -> string option
  
  (** {1:table Table} *)
  
  val artistId' : (t, int) Rel.Col.t
  val name' : (t, string option) Rel.Col.t
  
  val table : t Rel.Table.t
end = struct
  type t =
    { artistId : int;
      name : string option; }
    
  let row artistId name = { artistId; name }
  
  let artistId t = t.artistId
  let name t = t.name
  
  open Rel
  
  let artistId' = Col.v "ArtistId" Type.Int artistId
  let name' = Col.v "Name" Type.(Option Text) name
  
  let table =
    let row = Row.(unit row * artistId' * name') in
    let primary_key = [Col.V artistId'] in
    Table.v "Artist" row ~primary_key
end

module Album : sig
  type t
  
  val row : int -> string -> int -> t
  
  val albumId : t -> int
  val title : t -> string
  val artistId : t -> int
  
  (** {1:table Table} *)
  
  val albumId' : (t, int) Rel.Col.t
  val title' : (t, string) Rel.Col.t
  val artistId' : (t, int) Rel.Col.t
  
  val table : t Rel.Table.t
end = struct
  type t =
    { albumId : int;
      title : string;
      artistId : int; }
    
  let row albumId title artistId = { albumId; title; artistId }
  
  let albumId t = t.albumId
  let title t = t.title
  let artistId t = t.artistId
  
  open Rel
  
  let albumId' = Col.v "AlbumId" Type.Int albumId
  let title' = Col.v "Title" Type.Text title
  let artistId' = Col.v "ArtistId" Type.Int artistId
  
  let table =
    let row = Row.(unit row * albumId' * title' * artistId') in
    let primary_key = [Col.V albumId'] in
    let foreign_keys =
      [Table.foreign_key ~cols:[Col.V artistId']
         ~parent:(Artist.table, [Col.V Artist.artistId']) ()] in
    let indices =
      [Table.index ~name:"IFK_AlbumArtistId" [Col.V artistId']] in
    Table.v "Album" row ~primary_key ~foreign_keys ~indices
end

module Employee : sig
  type t
  
  val row : int -> string -> string -> string option -> int option ->
            float option -> float option -> string option -> string option ->
            string option -> string option -> string option ->
            string option -> string option -> string option -> t
  
  val employeeId : t -> int
  val lastName : t -> string
  val firstName : t -> string
  val title : t -> string option
  val reportsTo : t -> int option
  val birthDate : t -> float option
  val hireDate : t -> float option
  val address : t -> string option
  val city : t -> string option
  val state : t -> string option
  val country : t -> string option
  val postalCode : t -> string option
  val phone : t -> string option
  val fax : t -> string option
  val email : t -> string option
  
  (** {1:table Table} *)
  
  val employeeId' : (t, int) Rel.Col.t
  val lastName' : (t, string) Rel.Col.t
  val firstName' : (t, string) Rel.Col.t
  val title' : (t, string option) Rel.Col.t
  val reportsTo' : (t, int option) Rel.Col.t
  val birthDate' : (t, float option) Rel.Col.t
  val hireDate' : (t, float option) Rel.Col.t
  val address' : (t, string option) Rel.Col.t
  val city' : (t, string option) Rel.Col.t
  val state' : (t, string option) Rel.Col.t
  val country' : (t, string option) Rel.Col.t
  val postalCode' : (t, string option) Rel.Col.t
  val phone' : (t, string option) Rel.Col.t
  val fax' : (t, string option) Rel.Col.t
  val email' : (t, string option) Rel.Col.t
  
  val table : t Rel.Table.t
end = struct
  type t =
    { employeeId : int;
      lastName : string;
      firstName : string;
      title : string option;
      reportsTo : int option;
      birthDate : float option;
      hireDate : float option;
      address : string option;
      city : string option;
      state : string option;
      country : string option;
      postalCode : string option;
      phone : string option;
      fax : string option;
      email : string option; }
    
  let row employeeId lastName firstName title reportsTo birthDate hireDate
          address city state country postalCode phone fax email =
    { employeeId; lastName; firstName; title; reportsTo; birthDate; hireDate;
      address; city; state; country; postalCode; phone; fax; email }
  
  let employeeId t = t.employeeId
  let lastName t = t.lastName
  let firstName t = t.firstName
  let title t = t.title
  let reportsTo t = t.reportsTo
  let birthDate t = t.birthDate
  let hireDate t = t.hireDate
  let address t = t.address
  let city t = t.city
  let state t = t.state
  let country t = t.country
  let postalCode t = t.postalCode
  let phone t = t.phone
  let fax t = t.fax
  let email t = t.email
  
  open Rel
  
  let employeeId' = Col.v "EmployeeId" Type.Int employeeId
  let lastName' = Col.v "LastName" Type.Text lastName
  let firstName' = Col.v "FirstName" Type.Text firstName
  let title' = Col.v "Title" Type.(Option Text) title
  let reportsTo' = Col.v "ReportsTo" Type.(Option Int) reportsTo
  let birthDate' = Col.v "BirthDate" Type.(Option Float) birthDate
  let hireDate' = Col.v "HireDate" Type.(Option Float) hireDate
  let address' = Col.v "Address" Type.(Option Text) address
  let city' = Col.v "City" Type.(Option Text) city
  let state' = Col.v "State" Type.(Option Text) state
  let country' = Col.v "Country" Type.(Option Text) country
  let postalCode' = Col.v "PostalCode" Type.(Option Text) postalCode
  let phone' = Col.v "Phone" Type.(Option Text) phone
  let fax' = Col.v "Fax" Type.(Option Text) fax
  let email' = Col.v "Email" Type.(Option Text) email
  
  let table =
    let row =
      Row.(unit row * employeeId' * lastName' * firstName' * title' *
           reportsTo' * birthDate' * hireDate' * address' * city' * state' *
           country' * postalCode' * phone' * fax' * email') in
    let primary_key = [Col.V employeeId'] in
    let foreign_keys =
      [Table.self_foreign_key ~cols:[Col.V reportsTo']
         ~parent:[Col.V employeeId'] ()] in
    let indices =
      [Table.index ~name:"IFK_EmployeeReportsTo" [Col.V reportsTo']] in
    Table.v "Employee" row ~primary_key ~foreign_keys ~indices
end

module Customer : sig
  type t
  
  val row : int -> string -> string -> string option -> string option ->
            string option -> string option -> string option ->
            string option -> string option -> string option -> string ->
            int option -> t
  
  val customerId : t -> int
  val firstName : t -> string
  val lastName : t -> string
  val company : t -> string option
  val address : t -> string option
  val city : t -> string option
  val state : t -> string option
  val country : t -> string option
  val postalCode : t -> string option
  val phone : t -> string option
  val fax : t -> string option
  val email : t -> string
  val supportRepId : t -> int option
  
  (** {1:table Table} *)
  
  val customerId' : (t, int) Rel.Col.t
  val firstName' : (t, string) Rel.Col.t
  val lastName' : (t, string) Rel.Col.t
  val company' : (t, string option) Rel.Col.t
  val address' : (t, string option) Rel.Col.t
  val city' : (t, string option) Rel.Col.t
  val state' : (t, string option) Rel.Col.t
  val country' : (t, string option) Rel.Col.t
  val postalCode' : (t, string option) Rel.Col.t
  val phone' : (t, string option) Rel.Col.t
  val fax' : (t, string option) Rel.Col.t
  val email' : (t, string) Rel.Col.t
  val supportRepId' : (t, int option) Rel.Col.t
  
  val table : t Rel.Table.t
end = struct
  type t =
    { customerId : int;
      firstName : string;
      lastName : string;
      company : string option;
      address : string option;
      city : string option;
      state : string option;
      country : string option;
      postalCode : string option;
      phone : string option;
      fax : string option;
      email : string;
      supportRepId : int option; }
    
  let row customerId firstName lastName company address city state country
          postalCode phone fax email supportRepId =
    { customerId; firstName; lastName; company; address; city; state;
      country; postalCode; phone; fax; email; supportRepId }
  
  let customerId t = t.customerId
  let firstName t = t.firstName
  let lastName t = t.lastName
  let company t = t.company
  let address t = t.address
  let city t = t.city
  let state t = t.state
  let country t = t.country
  let postalCode t = t.postalCode
  let phone t = t.phone
  let fax t = t.fax
  let email t = t.email
  let supportRepId t = t.supportRepId
  
  open Rel
  
  let customerId' = Col.v "CustomerId" Type.Int customerId
  let firstName' = Col.v "FirstName" Type.Text firstName
  let lastName' = Col.v "LastName" Type.Text lastName
  let company' = Col.v "Company" Type.(Option Text) company
  let address' = Col.v "Address" Type.(Option Text) address
  let city' = Col.v "City" Type.(Option Text) city
  let state' = Col.v "State" Type.(Option Text) state
  let country' = Col.v "Country" Type.(Option Text) country
  let postalCode' = Col.v "PostalCode" Type.(Option Text) postalCode
  let phone' = Col.v "Phone" Type.(Option Text) phone
  let fax' = Col.v "Fax" Type.(Option Text) fax
  let email' = Col.v "Email" Type.Text email
  let supportRepId' = Col.v "SupportRepId" Type.(Option Int) supportRepId
  
  let table =
    let row =
      Row.(unit row * customerId' * firstName' * lastName' * company' *
           address' * city' * state' * country' * postalCode' * phone' *
           fax' * email' * supportRepId') in
    let primary_key = [Col.V customerId'] in
    let foreign_keys =
      [Table.foreign_key ~cols:[Col.V supportRepId']
         ~parent:(Employee.table, [Col.V Employee.employeeId']) ()] in
    let indices =
      [Table.index ~name:"IFK_CustomerSupportRepId" [Col.V supportRepId']] in
    Table.v "Customer" row ~primary_key ~foreign_keys ~indices
end

module Genre : sig
  type t
  
  val row : int -> string option -> t
  
  val genreId : t -> int
  val name : t -> string option
  
  (** {1:table Table} *)
  
  val genreId' : (t, int) Rel.Col.t
  val name' : (t, string option) Rel.Col.t
  
  val table : t Rel.Table.t
end = struct
  type t =
    { genreId : int;
      name : string option; }
    
  let row genreId name = { genreId; name }
  
  let genreId t = t.genreId
  let name t = t.name
  
  open Rel
  
  let genreId' = Col.v "GenreId" Type.Int genreId
  let name' = Col.v "Name" Type.(Option Text) name
  
  let table =
    let row = Row.(unit row * genreId' * name') in
    let primary_key = [Col.V genreId'] in
    Table.v "Genre" row ~primary_key
end

module Invoice : sig
  type t
  
  val row : int -> int -> float -> string option -> string option ->
            string option -> string option -> string option -> float -> t
  
  val invoiceId : t -> int
  val customerId : t -> int
  val invoiceDate : t -> float
  val billingAddress : t -> string option
  val billingCity : t -> string option
  val billingState : t -> string option
  val billingCountry : t -> string option
  val billingPostalCode : t -> string option
  val total : t -> float
  
  (** {1:table Table} *)
  
  val invoiceId' : (t, int) Rel.Col.t
  val customerId' : (t, int) Rel.Col.t
  val invoiceDate' : (t, float) Rel.Col.t
  val billingAddress' : (t, string option) Rel.Col.t
  val billingCity' : (t, string option) Rel.Col.t
  val billingState' : (t, string option) Rel.Col.t
  val billingCountry' : (t, string option) Rel.Col.t
  val billingPostalCode' : (t, string option) Rel.Col.t
  val total' : (t, float) Rel.Col.t
  
  val table : t Rel.Table.t
end = struct
  type t =
    { invoiceId : int;
      customerId : int;
      invoiceDate : float;
      billingAddress : string option;
      billingCity : string option;
      billingState : string option;
      billingCountry : string option;
      billingPostalCode : string option;
      total : float; }
    
  let row invoiceId customerId invoiceDate billingAddress billingCity
          billingState billingCountry billingPostalCode total =
    { invoiceId; customerId; invoiceDate; billingAddress; billingCity;
      billingState; billingCountry; billingPostalCode; total }
  
  let invoiceId t = t.invoiceId
  let customerId t = t.customerId
  let invoiceDate t = t.invoiceDate
  let billingAddress t = t.billingAddress
  let billingCity t = t.billingCity
  let billingState t = t.billingState
  let billingCountry t = t.billingCountry
  let billingPostalCode t = t.billingPostalCode
  let total t = t.total
  
  open Rel
  
  let invoiceId' = Col.v "InvoiceId" Type.Int invoiceId
  let customerId' = Col.v "CustomerId" Type.Int customerId
  let invoiceDate' = Col.v "InvoiceDate" Type.Float invoiceDate
  let billingAddress' =
    Col.v "BillingAddress" Type.(Option Text) billingAddress
  let billingCity' = Col.v "BillingCity" Type.(Option Text) billingCity
  let billingState' = Col.v "BillingState" Type.(Option Text) billingState
  let billingCountry' =
    Col.v "BillingCountry" Type.(Option Text) billingCountry
  let billingPostalCode' =
    Col.v "BillingPostalCode" Type.(Option Text) billingPostalCode
  let total' = Col.v "Total" Type.Float total
  
  let table =
    let row =
      Row.(unit row * invoiceId' * customerId' * invoiceDate' *
           billingAddress' * billingCity' * billingState' * billingCountry' *
           billingPostalCode' * total') in
    let primary_key = [Col.V invoiceId'] in
    let foreign_keys =
      [Table.foreign_key ~cols:[Col.V customerId']
         ~parent:(Customer.table, [Col.V Customer.customerId']) ()] in
    let indices =
      [Table.index ~name:"IFK_InvoiceCustomerId" [Col.V customerId']] in
    Table.v "Invoice" row ~primary_key ~foreign_keys ~indices
end

module MediaType : sig
  type t
  
  val row : int -> string option -> t
  
  val mediaTypeId : t -> int
  val name : t -> string option
  
  (** {1:table Table} *)
  
  val mediaTypeId' : (t, int) Rel.Col.t
  val name' : (t, string option) Rel.Col.t
  
  val table : t Rel.Table.t
end = struct
  type t =
    { mediaTypeId : int;
      name : string option; }
    
  let row mediaTypeId name = { mediaTypeId; name }
  
  let mediaTypeId t = t.mediaTypeId
  let name t = t.name
  
  open Rel
  
  let mediaTypeId' = Col.v "MediaTypeId" Type.Int mediaTypeId
  let name' = Col.v "Name" Type.(Option Text) name
  
  let table =
    let row = Row.(unit row * mediaTypeId' * name') in
    let primary_key = [Col.V mediaTypeId'] in
    Table.v "MediaType" row ~primary_key
end

module Track : sig
  type t
  
  val row : int -> string -> int option -> int -> int option ->
            string option -> int -> int option -> float -> t
  
  val trackId : t -> int
  val name : t -> string
  val albumId : t -> int option
  val mediaTypeId : t -> int
  val genreId : t -> int option
  val composer : t -> string option
  val milliseconds : t -> int
  val bytes : t -> int option
  val unitPrice : t -> float
  
  (** {1:table Table} *)
  
  val trackId' : (t, int) Rel.Col.t
  val name' : (t, string) Rel.Col.t
  val albumId' : (t, int option) Rel.Col.t
  val mediaTypeId' : (t, int) Rel.Col.t
  val genreId' : (t, int option) Rel.Col.t
  val composer' : (t, string option) Rel.Col.t
  val milliseconds' : (t, int) Rel.Col.t
  val bytes' : (t, int option) Rel.Col.t
  val unitPrice' : (t, float) Rel.Col.t
  
  val table : t Rel.Table.t
end = struct
  type t =
    { trackId : int;
      name : string;
      albumId : int option;
      mediaTypeId : int;
      genreId : int option;
      composer : string option;
      milliseconds : int;
      bytes : int option;
      unitPrice : float; }
    
  let row trackId name albumId mediaTypeId genreId composer milliseconds
          bytes unitPrice =
    { trackId; name; albumId; mediaTypeId; genreId; composer; milliseconds;
      bytes; unitPrice }
  
  let trackId t = t.trackId
  let name t = t.name
  let albumId t = t.albumId
  let mediaTypeId t = t.mediaTypeId
  let genreId t = t.genreId
  let composer t = t.composer
  let milliseconds t = t.milliseconds
  let bytes t = t.bytes
  let unitPrice t = t.unitPrice
  
  open Rel
  
  let trackId' = Col.v "TrackId" Type.Int trackId
  let name' = Col.v "Name" Type.Text name
  let albumId' = Col.v "AlbumId" Type.(Option Int) albumId
  let mediaTypeId' = Col.v "MediaTypeId" Type.Int mediaTypeId
  let genreId' = Col.v "GenreId" Type.(Option Int) genreId
  let composer' = Col.v "Composer" Type.(Option Text) composer
  let milliseconds' = Col.v "Milliseconds" Type.Int milliseconds
  let bytes' = Col.v "Bytes" Type.(Option Int) bytes
  let unitPrice' = Col.v "UnitPrice" Type.Float unitPrice
  
  let table =
    let row =
      Row.(unit row * trackId' * name' * albumId' * mediaTypeId' * genreId' *
           composer' * milliseconds' * bytes' * unitPrice') in
    let primary_key = [Col.V trackId'] in
    let foreign_keys =
      [Table.foreign_key ~cols:[Col.V albumId']
         ~parent:(Album.table, [Col.V Album.albumId']) ();
        Table.foreign_key ~cols:[Col.V genreId']
          ~parent:(Genre.table, [Col.V Genre.genreId']) ();
        Table.foreign_key ~cols:[Col.V mediaTypeId']
          ~parent:(MediaType.table, [Col.V MediaType.mediaTypeId']) ()] in
    let indices =
      [Table.index ~name:"IFK_TrackAlbumId" [Col.V albumId'];
       Table.index ~name:"IFK_TrackGenreId" [Col.V genreId'];
       Table.index ~name:"IFK_TrackMediaTypeId" [Col.V mediaTypeId']] in
    Table.v "Track" row ~primary_key ~foreign_keys ~indices
end

module InvoiceLine : sig
  type t
  
  val row : int -> int -> int -> float -> int -> t
  
  val invoiceLineId : t -> int
  val invoiceId : t -> int
  val trackId : t -> int
  val unitPrice : t -> float
  val quantity : t -> int
  
  (** {1:table Table} *)
  
  val invoiceLineId' : (t, int) Rel.Col.t
  val invoiceId' : (t, int) Rel.Col.t
  val trackId' : (t, int) Rel.Col.t
  val unitPrice' : (t, float) Rel.Col.t
  val quantity' : (t, int) Rel.Col.t
  
  val table : t Rel.Table.t
end = struct
  type t =
    { invoiceLineId : int;
      invoiceId : int;
      trackId : int;
      unitPrice : float;
      quantity : int; }
    
  let row invoiceLineId invoiceId trackId unitPrice quantity =
    { invoiceLineId; invoiceId; trackId; unitPrice; quantity }
  
  let invoiceLineId t = t.invoiceLineId
  let invoiceId t = t.invoiceId
  let trackId t = t.trackId
  let unitPrice t = t.unitPrice
  let quantity t = t.quantity
  
  open Rel
  
  let invoiceLineId' = Col.v "InvoiceLineId" Type.Int invoiceLineId
  let invoiceId' = Col.v "InvoiceId" Type.Int invoiceId
  let trackId' = Col.v "TrackId" Type.Int trackId
  let unitPrice' = Col.v "UnitPrice" Type.Float unitPrice
  let quantity' = Col.v "Quantity" Type.Int quantity
  
  let table =
    let row =
      Row.(unit row * invoiceLineId' * invoiceId' * trackId' * unitPrice' *
           quantity') in
    let primary_key = [Col.V invoiceLineId'] in
    let foreign_keys =
      [Table.foreign_key ~cols:[Col.V invoiceId']
         ~parent:(Invoice.table, [Col.V Invoice.invoiceId']) ();
        Table.foreign_key ~cols:[Col.V trackId']
          ~parent:(Track.table, [Col.V Track.trackId']) ()] in
    let indices =
      [Table.index ~name:"IFK_InvoiceLineInvoiceId" [Col.V invoiceId'];
       Table.index ~name:"IFK_InvoiceLineTrackId" [Col.V trackId']] in
    Table.v "InvoiceLine" row ~primary_key ~foreign_keys ~indices
end

module Playlist : sig
  type t
  
  val row : int -> string option -> t
  
  val playlistId : t -> int
  val name : t -> string option
  
  (** {1:table Table} *)
  
  val playlistId' : (t, int) Rel.Col.t
  val name' : (t, string option) Rel.Col.t
  
  val table : t Rel.Table.t
end = struct
  type t =
    { playlistId : int;
      name : string option; }
    
  let row playlistId name = { playlistId; name }
  
  let playlistId t = t.playlistId
  let name t = t.name
  
  open Rel
  
  let playlistId' = Col.v "PlaylistId" Type.Int playlistId
  let name' = Col.v "Name" Type.(Option Text) name
  
  let table =
    let row = Row.(unit row * playlistId' * name') in
    let primary_key = [Col.V playlistId'] in
    Table.v "Playlist" row ~primary_key
end

module PlaylistTrack : sig
  type t
  
  val row : int -> int -> t
  
  val playlistId : t -> int
  val trackId : t -> int
  
  (** {1:table Table} *)
  
  val playlistId' : (t, int) Rel.Col.t
  val trackId' : (t, int) Rel.Col.t
  
  val table : t Rel.Table.t
end = struct
  type t =
    { playlistId : int;
      trackId : int; }
    
  let row playlistId trackId = { playlistId; trackId }
  
  let playlistId t = t.playlistId
  let trackId t = t.trackId
  
  open Rel
  
  let playlistId' = Col.v "PlaylistId" Type.Int playlistId
  let trackId' = Col.v "TrackId" Type.Int trackId
  
  let table =
    let row = Row.(unit row * playlistId' * trackId') in
    let primary_key = [Col.V playlistId'; Col.V trackId'] in
    let foreign_keys =
      [Table.foreign_key ~cols:[Col.V playlistId']
         ~parent:(Playlist.table, [Col.V Playlist.playlistId']) ();
        Table.foreign_key ~cols:[Col.V trackId']
          ~parent:(Track.table, [Col.V Track.trackId']) ()] in
    let indices =
      [Table.index ~name:"IFK_PlaylistTrackTrackId" [Col.V trackId']] in
    Table.v "PlaylistTrack" row ~primary_key ~foreign_keys ~indices
end

module Schema : sig
  val v : Rel.Schema.t
end = struct
  let tables =
    [ Rel.Table.V Artist.table;
      Rel.Table.V Album.table;
      Rel.Table.V Employee.table;
      Rel.Table.V Customer.table;
      Rel.Table.V Genre.table;
      Rel.Table.V Invoice.table;
      Rel.Table.V MediaType.table;
      Rel.Table.V Track.table;
      Rel.Table.V InvoiceLine.table;
      Rel.Table.V Playlist.table;
      Rel.Table.V PlaylistTrack.table; ]
  
  let v = Rel.Schema.v ~tables ()
end
