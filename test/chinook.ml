(* Generated by rel-sqlite3 %VERSION% *)

module Track : sig
  type t

  val row : int -> string -> int option -> int -> int option ->
            string option -> int -> int option -> float -> t

  val trackId : t -> int
  val name : t -> string
  val albumId : t -> int option
  val mediaTypeId : t -> int
  val genreId : t -> int option
  val composer : t -> string option
  val milliseconds : t -> int
  val bytes : t -> int option
  val unitPrice : t -> float

  (** {1:table Table} *)

  val trackId' : (t, int) Rel.Col.t
  val name' : (t, string) Rel.Col.t
  val albumId' : (t, int option) Rel.Col.t
  val mediaTypeId' : (t, int) Rel.Col.t
  val genreId' : (t, int option) Rel.Col.t
  val composer' : (t, string option) Rel.Col.t
  val milliseconds' : (t, int) Rel.Col.t
  val bytes' : (t, int option) Rel.Col.t
  val unitPrice' : (t, float) Rel.Col.t

  val table : t Rel.Table.t
end = struct
  type t =
    { trackId : int;
      name : string;
      albumId : int option;
      mediaTypeId : int;
      genreId : int option;
      composer : string option;
      milliseconds : int;
      bytes : int option;
      unitPrice : float; }

  let row trackId name albumId mediaTypeId genreId composer milliseconds
          bytes unitPrice =
  { trackId; name; albumId; mediaTypeId; genreId; composer; milliseconds;
    bytes; unitPrice }

  let trackId t = t.trackId
  let name t = t.name
  let albumId t = t.albumId
  let mediaTypeId t = t.mediaTypeId
  let genreId t = t.genreId
  let composer t = t.composer
  let milliseconds t = t.milliseconds
  let bytes t = t.bytes
  let unitPrice t = t.unitPrice

  open Rel

  let trackId' = Col.v "TrackId" Type.Int trackId
  let name' = Col.v "Name" Type.Text name
  let albumId' = Col.v "AlbumId" Type.(Option Int) albumId
  let mediaTypeId' = Col.v "MediaTypeId" Type.Int mediaTypeId
  let genreId' = Col.v "GenreId" Type.(Option Int) genreId
  let composer' = Col.v "Composer" Type.(Option Text) composer
  let milliseconds' = Col.v "Milliseconds" Type.Int milliseconds
  let bytes' = Col.v "Bytes" Type.(Option Int) bytes
  let unitPrice' = Col.v "UnitPrice" Type.Float unitPrice

  let table =
    Table.v "Track"
      Row.(unit row * trackId' * name' * albumId' * mediaTypeId' * genreId' *
           composer' * milliseconds' * bytes' * unitPrice')
end

module PlaylistTrack : sig
  type t

  val row : int -> int -> t

  val playlistId : t -> int
  val trackId : t -> int

  (** {1:table Table} *)

  val playlistId' : (t, int) Rel.Col.t
  val trackId' : (t, int) Rel.Col.t

  val table : t Rel.Table.t
end = struct
  type t =
    { playlistId : int;
      trackId : int; }

  let row playlistId trackId = { playlistId; trackId }

  let playlistId t = t.playlistId
  let trackId t = t.trackId

  open Rel

  let playlistId' = Col.v "PlaylistId" Type.Int playlistId
  let trackId' = Col.v "TrackId" Type.Int trackId

  let table =
    Table.v "PlaylistTrack" Row.(unit row * playlistId' * trackId')
end

module Playlist : sig
  type t

  val row : int -> string option -> t

  val playlistId : t -> int
  val name : t -> string option

  (** {1:table Table} *)

  val playlistId' : (t, int) Rel.Col.t
  val name' : (t, string option) Rel.Col.t

  val table : t Rel.Table.t
end = struct
  type t =
    { playlistId : int;
      name : string option; }

  let row playlistId name = { playlistId; name }

  let playlistId t = t.playlistId
  let name t = t.name

  open Rel

  let playlistId' = Col.v "PlaylistId" Type.Int playlistId
  let name' = Col.v "Name" Type.(Option Text) name

  let table =
    Table.v "Playlist" Row.(unit row * playlistId' * name')
end

module MediaType : sig
  type t

  val row : int -> string option -> t

  val mediaTypeId : t -> int
  val name : t -> string option

  (** {1:table Table} *)

  val mediaTypeId' : (t, int) Rel.Col.t
  val name' : (t, string option) Rel.Col.t

  val table : t Rel.Table.t
end = struct
  type t =
    { mediaTypeId : int;
      name : string option; }

  let row mediaTypeId name = { mediaTypeId; name }

  let mediaTypeId t = t.mediaTypeId
  let name t = t.name

  open Rel

  let mediaTypeId' = Col.v "MediaTypeId" Type.Int mediaTypeId
  let name' = Col.v "Name" Type.(Option Text) name

  let table =
    Table.v "MediaType" Row.(unit row * mediaTypeId' * name')
end

module InvoiceLine : sig
  type t

  val row : int -> int -> int -> float -> int -> t

  val invoiceLineId : t -> int
  val invoiceId : t -> int
  val trackId : t -> int
  val unitPrice : t -> float
  val quantity : t -> int

  (** {1:table Table} *)

  val invoiceLineId' : (t, int) Rel.Col.t
  val invoiceId' : (t, int) Rel.Col.t
  val trackId' : (t, int) Rel.Col.t
  val unitPrice' : (t, float) Rel.Col.t
  val quantity' : (t, int) Rel.Col.t

  val table : t Rel.Table.t
end = struct
  type t =
    { invoiceLineId : int;
      invoiceId : int;
      trackId : int;
      unitPrice : float;
      quantity : int; }

  let row invoiceLineId invoiceId trackId unitPrice quantity =
  { invoiceLineId; invoiceId; trackId; unitPrice; quantity }

  let invoiceLineId t = t.invoiceLineId
  let invoiceId t = t.invoiceId
  let trackId t = t.trackId
  let unitPrice t = t.unitPrice
  let quantity t = t.quantity

  open Rel

  let invoiceLineId' = Col.v "InvoiceLineId" Type.Int invoiceLineId
  let invoiceId' = Col.v "InvoiceId" Type.Int invoiceId
  let trackId' = Col.v "TrackId" Type.Int trackId
  let unitPrice' = Col.v "UnitPrice" Type.Float unitPrice
  let quantity' = Col.v "Quantity" Type.Int quantity

  let table =
    Table.v "InvoiceLine"
      Row.(unit row * invoiceLineId' * invoiceId' * trackId' * unitPrice' *
           quantity')
end

module Invoice : sig
  type t

  val row : int -> int -> string -> string option -> string option ->
            string option -> string option -> string option -> float -> t

  val invoiceId : t -> int
  val customerId : t -> int
  val invoiceDate : t -> string
  val billingAddress : t -> string option
  val billingCity : t -> string option
  val billingState : t -> string option
  val billingCountry : t -> string option
  val billingPostalCode : t -> string option
  val total : t -> float

  (** {1:table Table} *)

  val invoiceId' : (t, int) Rel.Col.t
  val customerId' : (t, int) Rel.Col.t
  val invoiceDate' : (t, string) Rel.Col.t
  val billingAddress' : (t, string option) Rel.Col.t
  val billingCity' : (t, string option) Rel.Col.t
  val billingState' : (t, string option) Rel.Col.t
  val billingCountry' : (t, string option) Rel.Col.t
  val billingPostalCode' : (t, string option) Rel.Col.t
  val total' : (t, float) Rel.Col.t

  val table : t Rel.Table.t
end = struct
  type t =
    { invoiceId : int;
      customerId : int;
      invoiceDate : string;
      billingAddress : string option;
      billingCity : string option;
      billingState : string option;
      billingCountry : string option;
      billingPostalCode : string option;
      total : float; }

  let row invoiceId customerId invoiceDate billingAddress billingCity
          billingState billingCountry billingPostalCode total =
  { invoiceId; customerId; invoiceDate; billingAddress; billingCity;
    billingState; billingCountry; billingPostalCode; total }

  let invoiceId t = t.invoiceId
  let customerId t = t.customerId
  let invoiceDate t = t.invoiceDate
  let billingAddress t = t.billingAddress
  let billingCity t = t.billingCity
  let billingState t = t.billingState
  let billingCountry t = t.billingCountry
  let billingPostalCode t = t.billingPostalCode
  let total t = t.total

  open Rel

  let invoiceId' = Col.v "InvoiceId" Type.Int invoiceId
  let customerId' = Col.v "CustomerId" Type.Int customerId
  let invoiceDate' = Col.v "InvoiceDate" Type.Text invoiceDate
  let billingAddress' = Col.v "BillingAddress" Type.(Option Text) billingAddress
  let billingCity' = Col.v "BillingCity" Type.(Option Text) billingCity
  let billingState' = Col.v "BillingState" Type.(Option Text) billingState
  let billingCountry' = Col.v "BillingCountry" Type.(Option Text) billingCountry
  let billingPostalCode' = Col.v "BillingPostalCode" Type.(Option Text) billingPostalCode
  let total' = Col.v "Total" Type.Float total

  let table =
    Table.v "Invoice"
      Row.(unit row * invoiceId' * customerId' * invoiceDate' *
           billingAddress' * billingCity' * billingState' * billingCountry' *
           billingPostalCode' * total')
end

module Genre : sig
  type t

  val row : int -> string option -> t

  val genreId : t -> int
  val name : t -> string option

  (** {1:table Table} *)

  val genreId' : (t, int) Rel.Col.t
  val name' : (t, string option) Rel.Col.t

  val table : t Rel.Table.t
end = struct
  type t =
    { genreId : int;
      name : string option; }

  let row genreId name = { genreId; name }

  let genreId t = t.genreId
  let name t = t.name

  open Rel

  let genreId' = Col.v "GenreId" Type.Int genreId
  let name' = Col.v "Name" Type.(Option Text) name

  let table =
    Table.v "Genre" Row.(unit row * genreId' * name')
end

module Employee : sig
  type t

  val row : int -> string -> string -> string option -> int option ->
            string option -> string option -> string option ->
            string option -> string option -> string option ->
            string option -> string option -> string option ->
            string option -> t

  val employeeId : t -> int
  val lastName : t -> string
  val firstName : t -> string
  val title : t -> string option
  val reportsTo : t -> int option
  val birthDate : t -> string option
  val hireDate : t -> string option
  val address : t -> string option
  val city : t -> string option
  val state : t -> string option
  val country : t -> string option
  val postalCode : t -> string option
  val phone : t -> string option
  val fax : t -> string option
  val email : t -> string option

  (** {1:table Table} *)

  val employeeId' : (t, int) Rel.Col.t
  val lastName' : (t, string) Rel.Col.t
  val firstName' : (t, string) Rel.Col.t
  val title' : (t, string option) Rel.Col.t
  val reportsTo' : (t, int option) Rel.Col.t
  val birthDate' : (t, string option) Rel.Col.t
  val hireDate' : (t, string option) Rel.Col.t
  val address' : (t, string option) Rel.Col.t
  val city' : (t, string option) Rel.Col.t
  val state' : (t, string option) Rel.Col.t
  val country' : (t, string option) Rel.Col.t
  val postalCode' : (t, string option) Rel.Col.t
  val phone' : (t, string option) Rel.Col.t
  val fax' : (t, string option) Rel.Col.t
  val email' : (t, string option) Rel.Col.t

  val table : t Rel.Table.t
end = struct
  type t =
    { employeeId : int;
      lastName : string;
      firstName : string;
      title : string option;
      reportsTo : int option;
      birthDate : string option;
      hireDate : string option;
      address : string option;
      city : string option;
      state : string option;
      country : string option;
      postalCode : string option;
      phone : string option;
      fax : string option;
      email : string option; }

  let row employeeId lastName firstName title reportsTo birthDate hireDate
          address city state country postalCode phone fax email =
  { employeeId; lastName; firstName; title; reportsTo; birthDate; hireDate;
    address; city; state; country; postalCode; phone; fax; email }

  let employeeId t = t.employeeId
  let lastName t = t.lastName
  let firstName t = t.firstName
  let title t = t.title
  let reportsTo t = t.reportsTo
  let birthDate t = t.birthDate
  let hireDate t = t.hireDate
  let address t = t.address
  let city t = t.city
  let state t = t.state
  let country t = t.country
  let postalCode t = t.postalCode
  let phone t = t.phone
  let fax t = t.fax
  let email t = t.email

  open Rel

  let employeeId' = Col.v "EmployeeId" Type.Int employeeId
  let lastName' = Col.v "LastName" Type.Text lastName
  let firstName' = Col.v "FirstName" Type.Text firstName
  let title' = Col.v "Title" Type.(Option Text) title
  let reportsTo' = Col.v "ReportsTo" Type.(Option Int) reportsTo
  let birthDate' = Col.v "BirthDate" Type.(Option Text) birthDate
  let hireDate' = Col.v "HireDate" Type.(Option Text) hireDate
  let address' = Col.v "Address" Type.(Option Text) address
  let city' = Col.v "City" Type.(Option Text) city
  let state' = Col.v "State" Type.(Option Text) state
  let country' = Col.v "Country" Type.(Option Text) country
  let postalCode' = Col.v "PostalCode" Type.(Option Text) postalCode
  let phone' = Col.v "Phone" Type.(Option Text) phone
  let fax' = Col.v "Fax" Type.(Option Text) fax
  let email' = Col.v "Email" Type.(Option Text) email

  let table =
    Table.v "Employee"
      Row.(unit row * employeeId' * lastName' * firstName' * title' *
           reportsTo' * birthDate' * hireDate' * address' * city' * state' *
           country' * postalCode' * phone' * fax' * email')
end

module Customer : sig
  type t

  val row : int -> string -> string -> string option -> string option ->
            string option -> string option -> string option ->
            string option -> string option -> string option -> string ->
            int option -> t

  val customerId : t -> int
  val firstName : t -> string
  val lastName : t -> string
  val company : t -> string option
  val address : t -> string option
  val city : t -> string option
  val state : t -> string option
  val country : t -> string option
  val postalCode : t -> string option
  val phone : t -> string option
  val fax : t -> string option
  val email : t -> string
  val supportRepId : t -> int option

  (** {1:table Table} *)

  val customerId' : (t, int) Rel.Col.t
  val firstName' : (t, string) Rel.Col.t
  val lastName' : (t, string) Rel.Col.t
  val company' : (t, string option) Rel.Col.t
  val address' : (t, string option) Rel.Col.t
  val city' : (t, string option) Rel.Col.t
  val state' : (t, string option) Rel.Col.t
  val country' : (t, string option) Rel.Col.t
  val postalCode' : (t, string option) Rel.Col.t
  val phone' : (t, string option) Rel.Col.t
  val fax' : (t, string option) Rel.Col.t
  val email' : (t, string) Rel.Col.t
  val supportRepId' : (t, int option) Rel.Col.t

  val table : t Rel.Table.t
end = struct
  type t =
    { customerId : int;
      firstName : string;
      lastName : string;
      company : string option;
      address : string option;
      city : string option;
      state : string option;
      country : string option;
      postalCode : string option;
      phone : string option;
      fax : string option;
      email : string;
      supportRepId : int option; }

  let row customerId firstName lastName company address city state country
          postalCode phone fax email supportRepId =
  { customerId; firstName; lastName; company; address; city; state; country;
    postalCode; phone; fax; email; supportRepId }

  let customerId t = t.customerId
  let firstName t = t.firstName
  let lastName t = t.lastName
  let company t = t.company
  let address t = t.address
  let city t = t.city
  let state t = t.state
  let country t = t.country
  let postalCode t = t.postalCode
  let phone t = t.phone
  let fax t = t.fax
  let email t = t.email
  let supportRepId t = t.supportRepId

  open Rel

  let customerId' = Col.v "CustomerId" Type.Int customerId
  let firstName' = Col.v "FirstName" Type.Text firstName
  let lastName' = Col.v "LastName" Type.Text lastName
  let company' = Col.v "Company" Type.(Option Text) company
  let address' = Col.v "Address" Type.(Option Text) address
  let city' = Col.v "City" Type.(Option Text) city
  let state' = Col.v "State" Type.(Option Text) state
  let country' = Col.v "Country" Type.(Option Text) country
  let postalCode' = Col.v "PostalCode" Type.(Option Text) postalCode
  let phone' = Col.v "Phone" Type.(Option Text) phone
  let fax' = Col.v "Fax" Type.(Option Text) fax
  let email' = Col.v "Email" Type.Text email
  let supportRepId' = Col.v "SupportRepId" Type.(Option Int) supportRepId

  let table =
    Table.v "Customer"
      Row.(unit row * customerId' * firstName' * lastName' * company' *
           address' * city' * state' * country' * postalCode' * phone' *
           fax' * email' * supportRepId')
end

module Artist : sig
  type t

  val row : int -> string option -> t

  val artistId : t -> int
  val name : t -> string option

  (** {1:table Table} *)

  val artistId' : (t, int) Rel.Col.t
  val name' : (t, string option) Rel.Col.t

  val table : t Rel.Table.t
end = struct
  type t =
    { artistId : int;
      name : string option; }

  let row artistId name = { artistId; name }

  let artistId t = t.artistId
  let name t = t.name

  open Rel

  let artistId' = Col.v "ArtistId" Type.Int artistId
  let name' = Col.v "Name" Type.(Option Text) name

  let table =
    Table.v "Artist" Row.(unit row * artistId' * name')
end

module Album : sig
  type t

  val row : int -> string -> int -> t

  val albumId : t -> int
  val title : t -> string
  val artistId : t -> int

  (** {1:table Table} *)

  val albumId' : (t, int) Rel.Col.t
  val title' : (t, string) Rel.Col.t
  val artistId' : (t, int) Rel.Col.t

  val table : t Rel.Table.t
end = struct
  type t =
    { albumId : int;
      title : string;
      artistId : int; }

  let row albumId title artistId = { albumId; title; artistId }

  let albumId t = t.albumId
  let title t = t.title
  let artistId t = t.artistId

  open Rel

  let albumId' = Col.v "AlbumId" Type.Int albumId
  let title' = Col.v "Title" Type.Text title
  let artistId' = Col.v "ArtistId" Type.Int artistId

  let table =
    Table.v "Album" Row.(unit row * albumId' * title' * artistId')
end
