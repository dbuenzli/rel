(* Generated by ask-sqlite3 *)

module Tracks : sig
  type t
  val v : float -> int option -> int -> string option -> int option -> int ->
          int option -> string -> int -> t
  
  val unitPrice : t -> float
  val bytes : t -> int option
  val milliseconds : t -> int
  val composer : t -> string option
  val genreId : t -> int option
  val mediaTypeId : t -> int
  val albumId : t -> int option
  val name : t -> string
  val trackId : t -> int
  
  module C : sig
    val unitPrice : (t, float) Ask.Col.t
    val bytes : (t, int option) Ask.Col.t
    val milliseconds : (t, int) Ask.Col.t
    val composer : (t, string option) Ask.Col.t
    val genreId : (t, int option) Ask.Col.t
    val mediaTypeId : (t, int) Ask.Col.t
    val albumId : (t, int option) Ask.Col.t
    val name : (t, string) Ask.Col.t
    val trackId : (t, int) Ask.Col.t
  end
  
  val table : t Ask.Table.t
end = struct
  type t =
    { unitPrice : float;
      bytes : int option;
      milliseconds : int;
      composer : string option;
      genreId : int option;
      mediaTypeId : int;
      albumId : int option;
      name : string;
      trackId : int; }
    
  let v unitPrice bytes milliseconds composer genreId mediaTypeId albumId
        name trackId =
  { unitPrice; bytes; milliseconds; composer; genreId; mediaTypeId; albumId;
    name; trackId }
  
  let unitPrice t = t.unitPrice
  let bytes t = t.bytes
  let milliseconds t = t.milliseconds
  let composer t = t.composer
  let genreId t = t.genreId
  let mediaTypeId t = t.mediaTypeId
  let albumId t = t.albumId
  let name t = t.name
  let trackId t = t.trackId
  
  open Ask
  module C = struct
    let unitPrice = Col.v "UnitPrice" Type.Float unitPrice
    let bytes = Col.v "Bytes" Type.(Option Int) bytes
    let milliseconds = Col.v "Milliseconds" Type.Int milliseconds
    let composer = Col.v "Composer" Type.(Option Text) composer
    let genreId = Col.v "GenreId" Type.(Option Int) genreId
    let mediaTypeId = Col.v "MediaTypeId" Type.Int mediaTypeId
    let albumId = Col.v "AlbumId" Type.(Option Int) albumId
    let name = Col.v "Name" Type.Text name
    let trackId = Col.v "TrackId" Type.Int trackId
  end
  
  let table =
    Ask.Table.v "tracks" Row.Cols.(unit v * C.unitPrice * C.bytes *
                                   C.milliseconds * C.composer * C.genreId *
                                   C.mediaTypeId * C.albumId * C.name *
                                   C.trackId)
end

module Sqlite_stat1 : sig
  type t
  val v : string option -> string option -> string option -> t
  
  val stat : t -> string option
  val idx : t -> string option
  val tbl : t -> string option
  
  module C : sig
    val stat : (t, string option) Ask.Col.t
    val idx : (t, string option) Ask.Col.t
    val tbl : (t, string option) Ask.Col.t
  end
  
  val table : t Ask.Table.t
end = struct
  type t =
    { stat : string option;
      idx : string option;
      tbl : string option; }
    
  let v stat idx tbl = { stat; idx; tbl }
  
  let stat t = t.stat
  let idx t = t.idx
  let tbl t = t.tbl
  
  open Ask
  module C = struct
    let stat = Col.v "stat" Type.(Option Blob) stat
    let idx = Col.v "idx" Type.(Option Blob) idx
    let tbl = Col.v "tbl" Type.(Option Blob) tbl
  end
  
  let table =
    Ask.Table.v "sqlite_stat1" Row.Cols.(unit v * C.stat * C.idx * C.tbl)
end

module Sqlite_sequence : sig
  type t
  val v : string option -> string option -> t
  
  val seq : t -> string option
  val name : t -> string option
  
  module C : sig
    val seq : (t, string option) Ask.Col.t
    val name : (t, string option) Ask.Col.t
  end
  
  val table : t Ask.Table.t
end = struct
  type t =
    { seq : string option;
      name : string option; }
    
  let v seq name = { seq; name }
  
  let seq t = t.seq
  let name t = t.name
  
  open Ask
  module C = struct
    let seq = Col.v "seq" Type.(Option Blob) seq
    let name = Col.v "name" Type.(Option Blob) name
  end
  
  let table =
    Ask.Table.v "sqlite_sequence" Row.Cols.(unit v * C.seq * C.name)
end

module Playlists : sig
  type t
  val v : string option -> int -> t
  
  val name : t -> string option
  val playlistId : t -> int
  
  module C : sig
    val name : (t, string option) Ask.Col.t
    val playlistId : (t, int) Ask.Col.t
  end
  
  val table : t Ask.Table.t
end = struct
  type t =
    { name : string option;
      playlistId : int; }
    
  let v name playlistId = { name; playlistId }
  
  let name t = t.name
  let playlistId t = t.playlistId
  
  open Ask
  module C = struct
    let name = Col.v "Name" Type.(Option Text) name
    let playlistId = Col.v "PlaylistId" Type.Int playlistId
  end
  
  let table =
    Ask.Table.v "playlists" Row.Cols.(unit v * C.name * C.playlistId)
end

module Playlist_track : sig
  type t
  val v : int -> int -> t
  
  val trackId : t -> int
  val playlistId : t -> int
  
  module C : sig
    val trackId : (t, int) Ask.Col.t
    val playlistId : (t, int) Ask.Col.t
  end
  
  val table : t Ask.Table.t
end = struct
  type t =
    { trackId : int;
      playlistId : int; }
    
  let v trackId playlistId = { trackId; playlistId }
  
  let trackId t = t.trackId
  let playlistId t = t.playlistId
  
  open Ask
  module C = struct
    let trackId = Col.v "TrackId" Type.Int trackId
    let playlistId = Col.v "PlaylistId" Type.Int playlistId
  end
  
  let table =
    Ask.Table.v "playlist_track" Row.Cols.(unit v * C.trackId * C.playlistId)
end

module Media_types : sig
  type t
  val v : string option -> int -> t
  
  val name : t -> string option
  val mediaTypeId : t -> int
  
  module C : sig
    val name : (t, string option) Ask.Col.t
    val mediaTypeId : (t, int) Ask.Col.t
  end
  
  val table : t Ask.Table.t
end = struct
  type t =
    { name : string option;
      mediaTypeId : int; }
    
  let v name mediaTypeId = { name; mediaTypeId }
  
  let name t = t.name
  let mediaTypeId t = t.mediaTypeId
  
  open Ask
  module C = struct
    let name = Col.v "Name" Type.(Option Text) name
    let mediaTypeId = Col.v "MediaTypeId" Type.Int mediaTypeId
  end
  
  let table =
    Ask.Table.v "media_types" Row.Cols.(unit v * C.name * C.mediaTypeId)
end

module Invoices : sig
  type t
  val v : float -> string option -> string option -> string option ->
          string option -> string option -> string -> int -> int -> t
  
  val total : t -> float
  val billingPostalCode : t -> string option
  val billingCountry : t -> string option
  val billingState : t -> string option
  val billingCity : t -> string option
  val billingAddress : t -> string option
  val invoiceDate : t -> string
  val customerId : t -> int
  val invoiceId : t -> int
  
  module C : sig
    val total : (t, float) Ask.Col.t
    val billingPostalCode : (t, string option) Ask.Col.t
    val billingCountry : (t, string option) Ask.Col.t
    val billingState : (t, string option) Ask.Col.t
    val billingCity : (t, string option) Ask.Col.t
    val billingAddress : (t, string option) Ask.Col.t
    val invoiceDate : (t, string) Ask.Col.t
    val customerId : (t, int) Ask.Col.t
    val invoiceId : (t, int) Ask.Col.t
  end
  
  val table : t Ask.Table.t
end = struct
  type t =
    { total : float;
      billingPostalCode : string option;
      billingCountry : string option;
      billingState : string option;
      billingCity : string option;
      billingAddress : string option;
      invoiceDate : string;
      customerId : int;
      invoiceId : int; }
    
  let v total billingPostalCode billingCountry billingState billingCity
        billingAddress invoiceDate customerId invoiceId =
  { total; billingPostalCode; billingCountry; billingState; billingCity;
    billingAddress; invoiceDate; customerId; invoiceId }
  
  let total t = t.total
  let billingPostalCode t = t.billingPostalCode
  let billingCountry t = t.billingCountry
  let billingState t = t.billingState
  let billingCity t = t.billingCity
  let billingAddress t = t.billingAddress
  let invoiceDate t = t.invoiceDate
  let customerId t = t.customerId
  let invoiceId t = t.invoiceId
  
  open Ask
  module C = struct
    let total = Col.v "Total" Type.Float total
    let billingPostalCode = Col.v "BillingPostalCode" Type.(Option Text) billingPostalCode
    let billingCountry = Col.v "BillingCountry" Type.(Option Text) billingCountry
    let billingState = Col.v "BillingState" Type.(Option Text) billingState
    let billingCity = Col.v "BillingCity" Type.(Option Text) billingCity
    let billingAddress = Col.v "BillingAddress" Type.(Option Text) billingAddress
    let invoiceDate = Col.v "InvoiceDate" Type.Text invoiceDate
    let customerId = Col.v "CustomerId" Type.Int customerId
    let invoiceId = Col.v "InvoiceId" Type.Int invoiceId
  end
  
  let table =
    Ask.Table.v "invoices" Row.Cols.(unit v * C.total * C.billingPostalCode *
                                     C.billingCountry * C.billingState *
                                     C.billingCity * C.billingAddress *
                                     C.invoiceDate * C.customerId *
                                     C.invoiceId)
end

module Invoice_items : sig
  type t
  val v : int -> float -> int -> int -> int -> t
  
  val quantity : t -> int
  val unitPrice : t -> float
  val trackId : t -> int
  val invoiceId : t -> int
  val invoiceLineId : t -> int
  
  module C : sig
    val quantity : (t, int) Ask.Col.t
    val unitPrice : (t, float) Ask.Col.t
    val trackId : (t, int) Ask.Col.t
    val invoiceId : (t, int) Ask.Col.t
    val invoiceLineId : (t, int) Ask.Col.t
  end
  
  val table : t Ask.Table.t
end = struct
  type t =
    { quantity : int;
      unitPrice : float;
      trackId : int;
      invoiceId : int;
      invoiceLineId : int; }
    
  let v quantity unitPrice trackId invoiceId invoiceLineId =
  { quantity; unitPrice; trackId; invoiceId; invoiceLineId }
  
  let quantity t = t.quantity
  let unitPrice t = t.unitPrice
  let trackId t = t.trackId
  let invoiceId t = t.invoiceId
  let invoiceLineId t = t.invoiceLineId
  
  open Ask
  module C = struct
    let quantity = Col.v "Quantity" Type.Int quantity
    let unitPrice = Col.v "UnitPrice" Type.Float unitPrice
    let trackId = Col.v "TrackId" Type.Int trackId
    let invoiceId = Col.v "InvoiceId" Type.Int invoiceId
    let invoiceLineId = Col.v "InvoiceLineId" Type.Int invoiceLineId
  end
  
  let table =
    Ask.Table.v "invoice_items" Row.Cols.(unit v * C.quantity * C.unitPrice *
                                          C.trackId * C.invoiceId *
                                          C.invoiceLineId)
end

module Genres : sig
  type t
  val v : string option -> int -> t
  
  val name : t -> string option
  val genreId : t -> int
  
  module C : sig
    val name : (t, string option) Ask.Col.t
    val genreId : (t, int) Ask.Col.t
  end
  
  val table : t Ask.Table.t
end = struct
  type t =
    { name : string option;
      genreId : int; }
    
  let v name genreId = { name; genreId }
  
  let name t = t.name
  let genreId t = t.genreId
  
  open Ask
  module C = struct
    let name = Col.v "Name" Type.(Option Text) name
    let genreId = Col.v "GenreId" Type.Int genreId
  end
  
  let table =
    Ask.Table.v "genres" Row.Cols.(unit v * C.name * C.genreId)
end

module Employees : sig
  type t
  val v : string option -> string option -> string option -> string option ->
          string option -> string option -> string option -> string option ->
          string option -> string option -> int option -> string option ->
          string -> string -> int -> t
  
  val email : t -> string option
  val fax : t -> string option
  val phone : t -> string option
  val postalCode : t -> string option
  val country : t -> string option
  val state : t -> string option
  val city : t -> string option
  val address : t -> string option
  val hireDate : t -> string option
  val birthDate : t -> string option
  val reportsTo : t -> int option
  val title : t -> string option
  val firstName : t -> string
  val lastName : t -> string
  val employeeId : t -> int
  
  module C : sig
    val email : (t, string option) Ask.Col.t
    val fax : (t, string option) Ask.Col.t
    val phone : (t, string option) Ask.Col.t
    val postalCode : (t, string option) Ask.Col.t
    val country : (t, string option) Ask.Col.t
    val state : (t, string option) Ask.Col.t
    val city : (t, string option) Ask.Col.t
    val address : (t, string option) Ask.Col.t
    val hireDate : (t, string option) Ask.Col.t
    val birthDate : (t, string option) Ask.Col.t
    val reportsTo : (t, int option) Ask.Col.t
    val title : (t, string option) Ask.Col.t
    val firstName : (t, string) Ask.Col.t
    val lastName : (t, string) Ask.Col.t
    val employeeId : (t, int) Ask.Col.t
  end
  
  val table : t Ask.Table.t
end = struct
  type t =
    { email : string option;
      fax : string option;
      phone : string option;
      postalCode : string option;
      country : string option;
      state : string option;
      city : string option;
      address : string option;
      hireDate : string option;
      birthDate : string option;
      reportsTo : int option;
      title : string option;
      firstName : string;
      lastName : string;
      employeeId : int; }
    
  let v email fax phone postalCode country state city address hireDate
        birthDate reportsTo title firstName lastName employeeId =
  { email; fax; phone; postalCode; country; state; city; address; hireDate;
    birthDate; reportsTo; title; firstName; lastName; employeeId }
  
  let email t = t.email
  let fax t = t.fax
  let phone t = t.phone
  let postalCode t = t.postalCode
  let country t = t.country
  let state t = t.state
  let city t = t.city
  let address t = t.address
  let hireDate t = t.hireDate
  let birthDate t = t.birthDate
  let reportsTo t = t.reportsTo
  let title t = t.title
  let firstName t = t.firstName
  let lastName t = t.lastName
  let employeeId t = t.employeeId
  
  open Ask
  module C = struct
    let email = Col.v "Email" Type.(Option Text) email
    let fax = Col.v "Fax" Type.(Option Text) fax
    let phone = Col.v "Phone" Type.(Option Text) phone
    let postalCode = Col.v "PostalCode" Type.(Option Text) postalCode
    let country = Col.v "Country" Type.(Option Text) country
    let state = Col.v "State" Type.(Option Text) state
    let city = Col.v "City" Type.(Option Text) city
    let address = Col.v "Address" Type.(Option Text) address
    let hireDate = Col.v "HireDate" Type.(Option Text) hireDate
    let birthDate = Col.v "BirthDate" Type.(Option Text) birthDate
    let reportsTo = Col.v "ReportsTo" Type.(Option Int) reportsTo
    let title = Col.v "Title" Type.(Option Text) title
    let firstName = Col.v "FirstName" Type.Text firstName
    let lastName = Col.v "LastName" Type.Text lastName
    let employeeId = Col.v "EmployeeId" Type.Int employeeId
  end
  
  let table =
    Ask.Table.v "employees" Row.Cols.(unit v * C.email * C.fax * C.phone *
                                      C.postalCode * C.country * C.state *
                                      C.city * C.address * C.hireDate *
                                      C.birthDate * C.reportsTo * C.title *
                                      C.firstName * C.lastName *
                                      C.employeeId)
end

module Customers : sig
  type t
  val v : int option -> string -> string option -> string option ->
          string option -> string option -> string option -> string option ->
          string option -> string option -> string -> string -> int -> t
  
  val supportRepId : t -> int option
  val email : t -> string
  val fax : t -> string option
  val phone : t -> string option
  val postalCode : t -> string option
  val country : t -> string option
  val state : t -> string option
  val city : t -> string option
  val address : t -> string option
  val company : t -> string option
  val lastName : t -> string
  val firstName : t -> string
  val customerId : t -> int
  
  module C : sig
    val supportRepId : (t, int option) Ask.Col.t
    val email : (t, string) Ask.Col.t
    val fax : (t, string option) Ask.Col.t
    val phone : (t, string option) Ask.Col.t
    val postalCode : (t, string option) Ask.Col.t
    val country : (t, string option) Ask.Col.t
    val state : (t, string option) Ask.Col.t
    val city : (t, string option) Ask.Col.t
    val address : (t, string option) Ask.Col.t
    val company : (t, string option) Ask.Col.t
    val lastName : (t, string) Ask.Col.t
    val firstName : (t, string) Ask.Col.t
    val customerId : (t, int) Ask.Col.t
  end
  
  val table : t Ask.Table.t
end = struct
  type t =
    { supportRepId : int option;
      email : string;
      fax : string option;
      phone : string option;
      postalCode : string option;
      country : string option;
      state : string option;
      city : string option;
      address : string option;
      company : string option;
      lastName : string;
      firstName : string;
      customerId : int; }
    
  let v supportRepId email fax phone postalCode country state city address
        company lastName firstName customerId =
  { supportRepId; email; fax; phone; postalCode; country; state; city;
    address; company; lastName; firstName; customerId }
  
  let supportRepId t = t.supportRepId
  let email t = t.email
  let fax t = t.fax
  let phone t = t.phone
  let postalCode t = t.postalCode
  let country t = t.country
  let state t = t.state
  let city t = t.city
  let address t = t.address
  let company t = t.company
  let lastName t = t.lastName
  let firstName t = t.firstName
  let customerId t = t.customerId
  
  open Ask
  module C = struct
    let supportRepId = Col.v "SupportRepId" Type.(Option Int) supportRepId
    let email = Col.v "Email" Type.Text email
    let fax = Col.v "Fax" Type.(Option Text) fax
    let phone = Col.v "Phone" Type.(Option Text) phone
    let postalCode = Col.v "PostalCode" Type.(Option Text) postalCode
    let country = Col.v "Country" Type.(Option Text) country
    let state = Col.v "State" Type.(Option Text) state
    let city = Col.v "City" Type.(Option Text) city
    let address = Col.v "Address" Type.(Option Text) address
    let company = Col.v "Company" Type.(Option Text) company
    let lastName = Col.v "LastName" Type.Text lastName
    let firstName = Col.v "FirstName" Type.Text firstName
    let customerId = Col.v "CustomerId" Type.Int customerId
  end
  
  let table =
    Ask.Table.v "customers" Row.Cols.(unit v * C.supportRepId * C.email *
                                      C.fax * C.phone * C.postalCode *
                                      C.country * C.state * C.city *
                                      C.address * C.company * C.lastName *
                                      C.firstName * C.customerId)
end

module Artists : sig
  type t
  val v : string option -> int -> t
  
  val name : t -> string option
  val artistId : t -> int
  
  module C : sig
    val name : (t, string option) Ask.Col.t
    val artistId : (t, int) Ask.Col.t
  end
  
  val table : t Ask.Table.t
end = struct
  type t =
    { name : string option;
      artistId : int; }
    
  let v name artistId = { name; artistId }
  
  let name t = t.name
  let artistId t = t.artistId
  
  open Ask
  module C = struct
    let name = Col.v "Name" Type.(Option Text) name
    let artistId = Col.v "ArtistId" Type.Int artistId
  end
  
  let table =
    Ask.Table.v "artists" Row.Cols.(unit v * C.name * C.artistId)
end

module Albums : sig
  type t
  val v : int -> string -> int -> t
  
  val artistId : t -> int
  val title : t -> string
  val albumId : t -> int
  
  module C : sig
    val artistId : (t, int) Ask.Col.t
    val title : (t, string) Ask.Col.t
    val albumId : (t, int) Ask.Col.t
  end
  
  val table : t Ask.Table.t
end = struct
  type t =
    { artistId : int;
      title : string;
      albumId : int; }
    
  let v artistId title albumId = { artistId; title; albumId }
  
  let artistId t = t.artistId
  let title t = t.title
  let albumId t = t.albumId
  
  open Ask
  module C = struct
    let artistId = Col.v "ArtistId" Type.Int artistId
    let title = Col.v "Title" Type.Text title
    let albumId = Col.v "AlbumId" Type.Int albumId
  end
  
  let table =
    Ask.Table.v "albums" Row.Cols.(unit v * C.artistId * C.title * C.albumId)
end