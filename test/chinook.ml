(* Generated by rel %VERSION% *)

module Artist : sig
  type t
  
  val row : int -> string option -> t
  
  val artistId : t -> int
  val name : t -> string option
  
  (** {1:table Table} *)
  
  val artistId' : (t, int) Rel.Col.t
  val name' : (t, string option) Rel.Col.t
  
  val table : t Rel.Table.t
end = struct
  type t =
    { artistId : int;
      name : string option; }
    
  let row artistId name = { artistId; name }
  
  let artistId t = t.artistId
  let name t = t.name
  
  open Rel
  
  let artistId' = Col.make "ArtistId" Type.int artistId
  let name' = Col.make "Name" Type.(option text) name
  
  let table =
    let primary_key = Table.Primary_key.make [Col.Def artistId'] in
    Table.make "Artist"  ~primary_key @@
    Row.(unit row * artistId' * name')
end

module Album : sig
  type t
  
  val row : int -> string -> int -> t
  
  val albumId : t -> int
  val title : t -> string
  val artistId : t -> int
  
  (** {1:table Table} *)
  
  val albumId' : (t, int) Rel.Col.t
  val title' : (t, string) Rel.Col.t
  val artistId' : (t, int) Rel.Col.t
  
  val table : t Rel.Table.t
end = struct
  type t =
    { albumId : int;
      title : string;
      artistId : int; }
    
  let row albumId title artistId = { albumId; title; artistId }
  
  let albumId t = t.albumId
  let title t = t.title
  let artistId t = t.artistId
  
  open Rel
  
  let albumId' = Col.make "AlbumId" Type.int albumId
  let title' = Col.make "Title" Type.text title
  let artistId' = Col.make "ArtistId" Type.int artistId
  
  let table =
    let primary_key = Table.Primary_key.make [Col.Def albumId'] in
    let foreign_keys =
      [Table.Foreign_key.make ~cols:[Col.Def artistId']
         ~parent:(Table (Artist.table, [Col.Def Artist.artistId'])) ()] in
    let indices =
      [Table.Index.make ~name:"IFK_AlbumArtistId" [Col.Def artistId']] in
    Table.make "Album"  ~primary_key ~foreign_keys ~indices @@
    Row.(unit row * albumId' * title' * artistId')
end

module Employee : sig
  type t
  
  val row : int -> string -> string -> string option -> int option ->
            float option -> float option -> string option -> string option ->
            string option -> string option -> string option ->
            string option -> string option -> string option -> t
  
  val employeeId : t -> int
  val lastName : t -> string
  val firstName : t -> string
  val title : t -> string option
  val reportsTo : t -> int option
  val birthDate : t -> float option
  val hireDate : t -> float option
  val address : t -> string option
  val city : t -> string option
  val state : t -> string option
  val country : t -> string option
  val postalCode : t -> string option
  val phone : t -> string option
  val fax : t -> string option
  val email : t -> string option
  
  (** {1:table Table} *)
  
  val employeeId' : (t, int) Rel.Col.t
  val lastName' : (t, string) Rel.Col.t
  val firstName' : (t, string) Rel.Col.t
  val title' : (t, string option) Rel.Col.t
  val reportsTo' : (t, int option) Rel.Col.t
  val birthDate' : (t, float option) Rel.Col.t
  val hireDate' : (t, float option) Rel.Col.t
  val address' : (t, string option) Rel.Col.t
  val city' : (t, string option) Rel.Col.t
  val state' : (t, string option) Rel.Col.t
  val country' : (t, string option) Rel.Col.t
  val postalCode' : (t, string option) Rel.Col.t
  val phone' : (t, string option) Rel.Col.t
  val fax' : (t, string option) Rel.Col.t
  val email' : (t, string option) Rel.Col.t
  
  val table : t Rel.Table.t
end = struct
  type t =
    { employeeId : int;
      lastName : string;
      firstName : string;
      title : string option;
      reportsTo : int option;
      birthDate : float option;
      hireDate : float option;
      address : string option;
      city : string option;
      state : string option;
      country : string option;
      postalCode : string option;
      phone : string option;
      fax : string option;
      email : string option; }
    
  let row employeeId lastName firstName title reportsTo birthDate hireDate
          address city state country postalCode phone fax email =
    { employeeId; lastName; firstName; title; reportsTo; birthDate; hireDate;
      address; city; state; country; postalCode; phone; fax; email }
  
  let employeeId t = t.employeeId
  let lastName t = t.lastName
  let firstName t = t.firstName
  let title t = t.title
  let reportsTo t = t.reportsTo
  let birthDate t = t.birthDate
  let hireDate t = t.hireDate
  let address t = t.address
  let city t = t.city
  let state t = t.state
  let country t = t.country
  let postalCode t = t.postalCode
  let phone t = t.phone
  let fax t = t.fax
  let email t = t.email
  
  open Rel
  
  let employeeId' = Col.make "EmployeeId" Type.int employeeId
  let lastName' = Col.make "LastName" Type.text lastName
  let firstName' = Col.make "FirstName" Type.text firstName
  let title' = Col.make "Title" Type.(option text) title
  let reportsTo' = Col.make "ReportsTo" Type.(option int) reportsTo
  let birthDate' = Col.make "BirthDate" Type.(option float) birthDate
  let hireDate' = Col.make "HireDate" Type.(option float) hireDate
  let address' = Col.make "Address" Type.(option text) address
  let city' = Col.make "City" Type.(option text) city
  let state' = Col.make "State" Type.(option text) state
  let country' = Col.make "Country" Type.(option text) country
  let postalCode' = Col.make "PostalCode" Type.(option text) postalCode
  let phone' = Col.make "Phone" Type.(option text) phone
  let fax' = Col.make "Fax" Type.(option text) fax
  let email' = Col.make "Email" Type.(option text) email
  
  let table =
    let primary_key = Table.Primary_key.make [Col.Def employeeId'] in
    let foreign_keys =
      [Table.Foreign_key.make ~cols:[Col.Def reportsTo']
         ~parent:(Self [Col.Def employeeId']) ()] in
    let indices =
      [Table.Index.make ~name:"IFK_EmployeeReportsTo" [Col.Def reportsTo']] in
    Table.make "Employee"  ~primary_key ~foreign_keys ~indices @@
    Row.(unit row * employeeId' * lastName' * firstName' * title' *
         reportsTo' * birthDate' * hireDate' * address' * city' * state' *
         country' * postalCode' * phone' * fax' * email')
end

module Customer : sig
  type t
  
  val row : int -> string -> string -> string option -> string option ->
            string option -> string option -> string option ->
            string option -> string option -> string option -> string ->
            int option -> t
  
  val customerId : t -> int
  val firstName : t -> string
  val lastName : t -> string
  val company : t -> string option
  val address : t -> string option
  val city : t -> string option
  val state : t -> string option
  val country : t -> string option
  val postalCode : t -> string option
  val phone : t -> string option
  val fax : t -> string option
  val email : t -> string
  val supportRepId : t -> int option
  
  (** {1:table Table} *)
  
  val customerId' : (t, int) Rel.Col.t
  val firstName' : (t, string) Rel.Col.t
  val lastName' : (t, string) Rel.Col.t
  val company' : (t, string option) Rel.Col.t
  val address' : (t, string option) Rel.Col.t
  val city' : (t, string option) Rel.Col.t
  val state' : (t, string option) Rel.Col.t
  val country' : (t, string option) Rel.Col.t
  val postalCode' : (t, string option) Rel.Col.t
  val phone' : (t, string option) Rel.Col.t
  val fax' : (t, string option) Rel.Col.t
  val email' : (t, string) Rel.Col.t
  val supportRepId' : (t, int option) Rel.Col.t
  
  val table : t Rel.Table.t
end = struct
  type t =
    { customerId : int;
      firstName : string;
      lastName : string;
      company : string option;
      address : string option;
      city : string option;
      state : string option;
      country : string option;
      postalCode : string option;
      phone : string option;
      fax : string option;
      email : string;
      supportRepId : int option; }
    
  let row customerId firstName lastName company address city state country
          postalCode phone fax email supportRepId =
    { customerId; firstName; lastName; company; address; city; state;
      country; postalCode; phone; fax; email; supportRepId }
  
  let customerId t = t.customerId
  let firstName t = t.firstName
  let lastName t = t.lastName
  let company t = t.company
  let address t = t.address
  let city t = t.city
  let state t = t.state
  let country t = t.country
  let postalCode t = t.postalCode
  let phone t = t.phone
  let fax t = t.fax
  let email t = t.email
  let supportRepId t = t.supportRepId
  
  open Rel
  
  let customerId' = Col.make "CustomerId" Type.int customerId
  let firstName' = Col.make "FirstName" Type.text firstName
  let lastName' = Col.make "LastName" Type.text lastName
  let company' = Col.make "Company" Type.(option text) company
  let address' = Col.make "Address" Type.(option text) address
  let city' = Col.make "City" Type.(option text) city
  let state' = Col.make "State" Type.(option text) state
  let country' = Col.make "Country" Type.(option text) country
  let postalCode' = Col.make "PostalCode" Type.(option text) postalCode
  let phone' = Col.make "Phone" Type.(option text) phone
  let fax' = Col.make "Fax" Type.(option text) fax
  let email' = Col.make "Email" Type.text email
  let supportRepId' = Col.make "SupportRepId" Type.(option int) supportRepId
  
  let table =
    let primary_key = Table.Primary_key.make [Col.Def customerId'] in
    let foreign_keys =
      [Table.Foreign_key.make ~cols:[Col.Def supportRepId']
         ~parent:(Table (Employee.table, [Col.Def Employee.employeeId'])) ()] in
    let indices =
      [Table.Index.make ~name:"IFK_CustomerSupportRepId"
         [Col.Def supportRepId']] in
    Table.make "Customer"  ~primary_key ~foreign_keys ~indices @@
    Row.(unit row * customerId' * firstName' * lastName' * company' *
         address' * city' * state' * country' * postalCode' * phone' * fax' *
         email' * supportRepId')
end

module Genre : sig
  type t
  
  val row : int -> string option -> t
  
  val genreId : t -> int
  val name : t -> string option
  
  (** {1:table Table} *)
  
  val genreId' : (t, int) Rel.Col.t
  val name' : (t, string option) Rel.Col.t
  
  val table : t Rel.Table.t
end = struct
  type t =
    { genreId : int;
      name : string option; }
    
  let row genreId name = { genreId; name }
  
  let genreId t = t.genreId
  let name t = t.name
  
  open Rel
  
  let genreId' = Col.make "GenreId" Type.int genreId
  let name' = Col.make "Name" Type.(option text) name
  
  let table =
    let primary_key = Table.Primary_key.make [Col.Def genreId'] in
    Table.make "Genre"  ~primary_key @@
    Row.(unit row * genreId' * name')
end

module Invoice : sig
  type t
  
  val row : int -> int -> float -> string option -> string option ->
            string option -> string option -> string option -> float -> t
  
  val invoiceId : t -> int
  val customerId : t -> int
  val invoiceDate : t -> float
  val billingAddress : t -> string option
  val billingCity : t -> string option
  val billingState : t -> string option
  val billingCountry : t -> string option
  val billingPostalCode : t -> string option
  val total : t -> float
  
  (** {1:table Table} *)
  
  val invoiceId' : (t, int) Rel.Col.t
  val customerId' : (t, int) Rel.Col.t
  val invoiceDate' : (t, float) Rel.Col.t
  val billingAddress' : (t, string option) Rel.Col.t
  val billingCity' : (t, string option) Rel.Col.t
  val billingState' : (t, string option) Rel.Col.t
  val billingCountry' : (t, string option) Rel.Col.t
  val billingPostalCode' : (t, string option) Rel.Col.t
  val total' : (t, float) Rel.Col.t
  
  val table : t Rel.Table.t
end = struct
  type t =
    { invoiceId : int;
      customerId : int;
      invoiceDate : float;
      billingAddress : string option;
      billingCity : string option;
      billingState : string option;
      billingCountry : string option;
      billingPostalCode : string option;
      total : float; }
    
  let row invoiceId customerId invoiceDate billingAddress billingCity
          billingState billingCountry billingPostalCode total =
    { invoiceId; customerId; invoiceDate; billingAddress; billingCity;
      billingState; billingCountry; billingPostalCode; total }
  
  let invoiceId t = t.invoiceId
  let customerId t = t.customerId
  let invoiceDate t = t.invoiceDate
  let billingAddress t = t.billingAddress
  let billingCity t = t.billingCity
  let billingState t = t.billingState
  let billingCountry t = t.billingCountry
  let billingPostalCode t = t.billingPostalCode
  let total t = t.total
  
  open Rel
  
  let invoiceId' = Col.make "InvoiceId" Type.int invoiceId
  let customerId' = Col.make "CustomerId" Type.int customerId
  let invoiceDate' = Col.make "InvoiceDate" Type.float invoiceDate
  let billingAddress' =
    Col.make "BillingAddress" Type.(option text) billingAddress
  let billingCity' = Col.make "BillingCity" Type.(option text) billingCity
  let billingState' = Col.make "BillingState" Type.(option text) billingState
  let billingCountry' =
    Col.make "BillingCountry" Type.(option text) billingCountry
  let billingPostalCode' =
    Col.make "BillingPostalCode" Type.(option text) billingPostalCode
  let total' = Col.make "Total" Type.float total
  
  let table =
    let primary_key = Table.Primary_key.make [Col.Def invoiceId'] in
    let foreign_keys =
      [Table.Foreign_key.make ~cols:[Col.Def customerId']
         ~parent:(Table (Customer.table, [Col.Def Customer.customerId'])) ()] in
    let indices =
      [Table.Index.make ~name:"IFK_InvoiceCustomerId" [Col.Def customerId']] in
    Table.make "Invoice"  ~primary_key ~foreign_keys ~indices @@
    Row.(unit row * invoiceId' * customerId' * invoiceDate' *
         billingAddress' * billingCity' * billingState' * billingCountry' *
         billingPostalCode' * total')
end

module MediaType : sig
  type t
  
  val row : int -> string option -> t
  
  val mediaTypeId : t -> int
  val name : t -> string option
  
  (** {1:table Table} *)
  
  val mediaTypeId' : (t, int) Rel.Col.t
  val name' : (t, string option) Rel.Col.t
  
  val table : t Rel.Table.t
end = struct
  type t =
    { mediaTypeId : int;
      name : string option; }
    
  let row mediaTypeId name = { mediaTypeId; name }
  
  let mediaTypeId t = t.mediaTypeId
  let name t = t.name
  
  open Rel
  
  let mediaTypeId' = Col.make "MediaTypeId" Type.int mediaTypeId
  let name' = Col.make "Name" Type.(option text) name
  
  let table =
    let primary_key = Table.Primary_key.make [Col.Def mediaTypeId'] in
    Table.make "MediaType"  ~primary_key @@
    Row.(unit row * mediaTypeId' * name')
end

module Track : sig
  type t
  
  val row : int -> string -> int option -> int -> int option ->
            string option -> int -> int option -> float -> t
  
  val trackId : t -> int
  val name : t -> string
  val albumId : t -> int option
  val mediaTypeId : t -> int
  val genreId : t -> int option
  val composer : t -> string option
  val milliseconds : t -> int
  val bytes : t -> int option
  val unitPrice : t -> float
  
  (** {1:table Table} *)
  
  val trackId' : (t, int) Rel.Col.t
  val name' : (t, string) Rel.Col.t
  val albumId' : (t, int option) Rel.Col.t
  val mediaTypeId' : (t, int) Rel.Col.t
  val genreId' : (t, int option) Rel.Col.t
  val composer' : (t, string option) Rel.Col.t
  val milliseconds' : (t, int) Rel.Col.t
  val bytes' : (t, int option) Rel.Col.t
  val unitPrice' : (t, float) Rel.Col.t
  
  val table : t Rel.Table.t
end = struct
  type t =
    { trackId : int;
      name : string;
      albumId : int option;
      mediaTypeId : int;
      genreId : int option;
      composer : string option;
      milliseconds : int;
      bytes : int option;
      unitPrice : float; }
    
  let row trackId name albumId mediaTypeId genreId composer milliseconds
          bytes unitPrice =
    { trackId; name; albumId; mediaTypeId; genreId; composer; milliseconds;
      bytes; unitPrice }
  
  let trackId t = t.trackId
  let name t = t.name
  let albumId t = t.albumId
  let mediaTypeId t = t.mediaTypeId
  let genreId t = t.genreId
  let composer t = t.composer
  let milliseconds t = t.milliseconds
  let bytes t = t.bytes
  let unitPrice t = t.unitPrice
  
  open Rel
  
  let trackId' = Col.make "TrackId" Type.int trackId
  let name' = Col.make "Name" Type.text name
  let albumId' = Col.make "AlbumId" Type.(option int) albumId
  let mediaTypeId' = Col.make "MediaTypeId" Type.int mediaTypeId
  let genreId' = Col.make "GenreId" Type.(option int) genreId
  let composer' = Col.make "Composer" Type.(option text) composer
  let milliseconds' = Col.make "Milliseconds" Type.int milliseconds
  let bytes' = Col.make "Bytes" Type.(option int) bytes
  let unitPrice' = Col.make "UnitPrice" Type.float unitPrice
  
  let table =
    let primary_key = Table.Primary_key.make [Col.Def trackId'] in
    let foreign_keys =
      [Table.Foreign_key.make ~cols:[Col.Def albumId']
         ~parent:(Table (Album.table, [Col.Def Album.albumId'])) ();
        Table.Foreign_key.make ~cols:[Col.Def genreId']
          ~parent:(Table (Genre.table, [Col.Def Genre.genreId'])) ();
        Table.Foreign_key.make ~cols:[Col.Def mediaTypeId']
          ~parent:(Table (MediaType.table, [Col.Def MediaType.mediaTypeId'])) ()] in
    let indices =
      [Table.Index.make ~name:"IFK_TrackAlbumId" [Col.Def albumId'];
       Table.Index.make ~name:"IFK_TrackGenreId" [Col.Def genreId'];
       Table.Index.make ~name:"IFK_TrackMediaTypeId" [Col.Def mediaTypeId']] in
    Table.make "Track"  ~primary_key ~foreign_keys ~indices @@
    Row.(unit row * trackId' * name' * albumId' * mediaTypeId' * genreId' *
         composer' * milliseconds' * bytes' * unitPrice')
end

module InvoiceLine : sig
  type t
  
  val row : int -> int -> int -> float -> int -> t
  
  val invoiceLineId : t -> int
  val invoiceId : t -> int
  val trackId : t -> int
  val unitPrice : t -> float
  val quantity : t -> int
  
  (** {1:table Table} *)
  
  val invoiceLineId' : (t, int) Rel.Col.t
  val invoiceId' : (t, int) Rel.Col.t
  val trackId' : (t, int) Rel.Col.t
  val unitPrice' : (t, float) Rel.Col.t
  val quantity' : (t, int) Rel.Col.t
  
  val table : t Rel.Table.t
end = struct
  type t =
    { invoiceLineId : int;
      invoiceId : int;
      trackId : int;
      unitPrice : float;
      quantity : int; }
    
  let row invoiceLineId invoiceId trackId unitPrice quantity =
    { invoiceLineId; invoiceId; trackId; unitPrice; quantity }
  
  let invoiceLineId t = t.invoiceLineId
  let invoiceId t = t.invoiceId
  let trackId t = t.trackId
  let unitPrice t = t.unitPrice
  let quantity t = t.quantity
  
  open Rel
  
  let invoiceLineId' = Col.make "InvoiceLineId" Type.int invoiceLineId
  let invoiceId' = Col.make "InvoiceId" Type.int invoiceId
  let trackId' = Col.make "TrackId" Type.int trackId
  let unitPrice' = Col.make "UnitPrice" Type.float unitPrice
  let quantity' = Col.make "Quantity" Type.int quantity
  
  let table =
    let primary_key = Table.Primary_key.make [Col.Def invoiceLineId'] in
    let foreign_keys =
      [Table.Foreign_key.make ~cols:[Col.Def invoiceId']
         ~parent:(Table (Invoice.table, [Col.Def Invoice.invoiceId'])) ();
        Table.Foreign_key.make ~cols:[Col.Def trackId']
          ~parent:(Table (Track.table, [Col.Def Track.trackId'])) ()] in
    let indices =
      [Table.Index.make ~name:"IFK_InvoiceLineInvoiceId" [Col.Def invoiceId'];
       Table.Index.make ~name:"IFK_InvoiceLineTrackId" [Col.Def trackId']] in
    Table.make "InvoiceLine"  ~primary_key ~foreign_keys ~indices @@
    Row.(unit row * invoiceLineId' * invoiceId' * trackId' * unitPrice' *
         quantity')
end

module Playlist : sig
  type t
  
  val row : int -> string option -> t
  
  val playlistId : t -> int
  val name : t -> string option
  
  (** {1:table Table} *)
  
  val playlistId' : (t, int) Rel.Col.t
  val name' : (t, string option) Rel.Col.t
  
  val table : t Rel.Table.t
end = struct
  type t =
    { playlistId : int;
      name : string option; }
    
  let row playlistId name = { playlistId; name }
  
  let playlistId t = t.playlistId
  let name t = t.name
  
  open Rel
  
  let playlistId' = Col.make "PlaylistId" Type.int playlistId
  let name' = Col.make "Name" Type.(option text) name
  
  let table =
    let primary_key = Table.Primary_key.make [Col.Def playlistId'] in
    Table.make "Playlist"  ~primary_key @@
    Row.(unit row * playlistId' * name')
end

module PlaylistTrack : sig
  type t
  
  val row : int -> int -> t
  
  val playlistId : t -> int
  val trackId : t -> int
  
  (** {1:table Table} *)
  
  val playlistId' : (t, int) Rel.Col.t
  val trackId' : (t, int) Rel.Col.t
  
  val table : t Rel.Table.t
end = struct
  type t =
    { playlistId : int;
      trackId : int; }
    
  let row playlistId trackId = { playlistId; trackId }
  
  let playlistId t = t.playlistId
  let trackId t = t.trackId
  
  open Rel
  
  let playlistId' = Col.make "PlaylistId" Type.int playlistId
  let trackId' = Col.make "TrackId" Type.int trackId
  
  let table =
    let primary_key =
      Table.Primary_key.make [Col.Def playlistId'; Col.Def trackId'] in
    let foreign_keys =
      [Table.Foreign_key.make ~cols:[Col.Def playlistId']
         ~parent:(Table (Playlist.table, [Col.Def Playlist.playlistId'])) ();
        Table.Foreign_key.make ~cols:[Col.Def trackId']
          ~parent:(Table (Track.table, [Col.Def Track.trackId'])) ()] in
    let indices =
      [Table.Index.make ~name:"IFK_PlaylistTrackTrackId" [Col.Def trackId']] in
    Table.make "PlaylistTrack"  ~primary_key ~foreign_keys ~indices @@
    Row.(unit row * playlistId' * trackId')
end

module Schema : sig
  val v : Rel.Schema.t
end = struct
  let tables =
    [ Rel.Table.Def Artist.table;
      Rel.Table.Def Album.table;
      Rel.Table.Def Employee.table;
      Rel.Table.Def Customer.table;
      Rel.Table.Def Genre.table;
      Rel.Table.Def Invoice.table;
      Rel.Table.Def MediaType.table;
      Rel.Table.Def Track.table;
      Rel.Table.Def InvoiceLine.table;
      Rel.Table.Def Playlist.table;
      Rel.Table.Def PlaylistTrack.table; ]
  
  let v = Rel.Schema.make ~tables ()
end
